{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/landscape/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1531711262215},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1531711262216},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1531711262216},{"_id":"themes/landscape/README.md","hash":"f34fa1687b6a21eff738b99a957c2f421172aab2","modified":1531711262216},{"_id":"themes/landscape/_config.yml","hash":"79ac6b9ed6a4de5a21ea53fc3f5a3de92e2475ff","modified":1531711262216},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1531711262226},{"_id":"source/_posts/2017-04-23-front_Back_organization.md","hash":"a4492b485614655c5ffe06510eb94683799310da","modified":1531711262194},{"_id":"source/_posts/2017-05-02_git_command.md","hash":"7c9db05a31b5724fa57798d09484e9f72085b6c8","modified":1531711262194},{"_id":"source/_posts/2017-12-08_前端架构.md","hash":"01c15c2aead8d45523d19056181fb2bf46e06e86","modified":1531711262194},{"_id":"source/_posts/2018-02-01_API文档生成工具.md","hash":"c420e9f35396f60bd7fa91a346753781e2f1d211","modified":1531711262194},{"_id":"source/_posts/2018-03-14_http.md","hash":"c5d7628c9694a0ec607893c9a311150297d9d56f","modified":1531711262194},{"_id":"source/_posts/2018-04-17-css-vs-js-animation-performance.md","hash":"32104aaea09c87c6c7e5963f00b09c1e54d200ae","modified":1531711262194},{"_id":"source/_posts/2018-04-27_react_pile_from_parent_to_child_component.md","hash":"58b923b905854857f135de81eb3d16e58e8d239e","modified":1531711262195},{"_id":"source/_posts/2018-05-02_ref_of_react.md","hash":"a5801ac29b1304e6eed7682d9ae5d5fb86fbb9d4","modified":1531711262195},{"_id":"source/_posts/hello-world.md","hash":"4d40d207ca8c0907210e06e2c66caf58dc50d53e","modified":1531711262195},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1531711262217},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1531711262217},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1531711262217},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1531711262217},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1531711262217},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1531711262218},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1531711262218},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1531711262218},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1531711262218},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1531711262219},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1531711262219},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1531711262219},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1531711262224},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1531711262224},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1531711262225},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1531711262225},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1531711262225},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1531711262225},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1531711262226},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1531711262226},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"d0d753d39038284d52b10e5075979cc97db9cd20","modified":1531711262219},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1531711262220},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1531711262220},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1531711262220},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1531711262220},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1531711262220},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1531711262221},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"5abf77aec957d9445fc71a8310252f0013c84578","modified":1531711262221},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"7e749050be126eadbc42decfbea75124ae430413","modified":1531711262221},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1531711262221},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1531711262223},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1531711262223},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1531711262223},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1531711262224},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1531711262224},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1531711262224},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1531711262227},{"_id":"themes/landscape/source/css/_variables.styl","hash":"628e307579ea46b5928424313993f17b8d729e92","modified":1531711262230},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1531711262234},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1531711262235},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1531711262235},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1531711262235},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1531711262235},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1531711262236},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1531711262236},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1531711262237},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1531711262238},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1531711262239},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1531711262238},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1531711262222},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1531711262222},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1531711262222},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1531711262222},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1531711262222},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1531711262223},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1531711262227},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1531711262227},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1531711262227},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1531711262228},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1531711262228},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1531711262228},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1531711262228},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1531711262228},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1531711262229},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1531711262229},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1531711262229},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1531711262229},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1531711262230},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1531711262231},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1531711262233},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1531711262236},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1531711262236},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1531711262237},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1531711262237},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1531711262237},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1531711262237},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1531711262232},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1531711262232},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1531711262234},{"_id":"public/2018/04/27/2018-04-27_react_pile_from_parent_to_child_component/index.html","hash":"d2f569358aec58a9e97c9804cee7f37935731775","modified":1531712439833},{"_id":"public/2018/03/14/2018-03-14_http/index.html","hash":"ac2cbc1cd94e306e895b3dc6fd95c31b3ec09330","modified":1531712439850},{"_id":"public/2018/02/01/2018-02-01_API文档生成工具/index.html","hash":"e8c26f5df69ccb923aa5490072596909f1cbaece","modified":1531712439850},{"_id":"public/2017/12/08/2017-12-08_前端架构/index.html","hash":"c153f39d2cb0e6f09fa478417d68e84caefea726","modified":1531712439853},{"_id":"public/2017/04/23/2017-04-23-front_Back_organization/index.html","hash":"d383aae01cbca56c34ad5e99615b5860dd92ef93","modified":1531712439850},{"_id":"public/2017/04/22/hello-world/index.html","hash":"afc0482d436c85924332a298040d0e15e6729ef3","modified":1531712439850},{"_id":"public/archives/index.html","hash":"72a1bfaf2c822d378d70f86b338ac1441ba5bdb9","modified":1531712439851},{"_id":"public/archives/2017/index.html","hash":"fa657d39406aa90c0670e25239f752321a47fef1","modified":1531712439851},{"_id":"public/archives/2017/04/index.html","hash":"8cadd6f8b5bf29325e708827454f0fade99d0de2","modified":1531712439851},{"_id":"public/archives/2017/05/index.html","hash":"3f7178159a2f21cb3182027d9a6781cf8a440cdd","modified":1531712439851},{"_id":"public/archives/2017/12/index.html","hash":"1a959baebb5d6b843c0464cb5e17e137ddb346f0","modified":1531712439851},{"_id":"public/archives/2018/index.html","hash":"8e8e4cb29090c2f23c1adfdea7476b6ccc256256","modified":1531712439851},{"_id":"public/archives/2018/02/index.html","hash":"d3fcd276dd4e655f370bbb56fb5bde5b8b0df5e2","modified":1531712439851},{"_id":"public/archives/2018/03/index.html","hash":"d558d0df427d29ab2c73934c0e738f45dccfaf89","modified":1531712439851},{"_id":"public/archives/2018/04/index.html","hash":"afc4f057a87da0af9a031bd5340ab521edc8a382","modified":1531712439851},{"_id":"public/archives/2018/05/index.html","hash":"d2559fe0e7667733691385f7f595a3e1d0a81382","modified":1531712439852},{"_id":"public/tags/前端工程化/index.html","hash":"ce206b31452df39a3c47afd01c60036f5787194b","modified":1531712439852},{"_id":"public/tags/前后端分离/index.html","hash":"0fe1cb04c1a822db23f98b3a277c2f3859078f5b","modified":1531712439852},{"_id":"public/tags/Git/index.html","hash":"c59de527663c5a65deca912d00ea2444f2c5ae7f","modified":1531712439852},{"_id":"public/tags/前端架构/index.html","hash":"209bd41217149491e00735112a516a1233c9ee61","modified":1531712439852},{"_id":"public/tags/API/index.html","hash":"6176f44bf8278f507d5e7f4fae0f2fb8892842d1","modified":1531712439852},{"_id":"public/tags/工具/index.html","hash":"6f40dabbf88b94225e4008a48b3b84ebcd7b9718","modified":1531712439852},{"_id":"public/tags/HTTP/index.html","hash":"d8860380024b9ab122e77484385a80f6915cc217","modified":1531712439852},{"_id":"public/tags/CSS/index.html","hash":"3bee10227bb4d90a8b61a8b22621d13b6ce81400","modified":1531712439852},{"_id":"public/tags/JavaScript/index.html","hash":"bde66b951e5e0681d56e060b118bb3dae36b5612","modified":1531712439852},{"_id":"public/tags/前端动画/index.html","hash":"b73c00dd883ef3b8d74d3d526c3903e517a26613","modified":1531712439852},{"_id":"public/tags/React/index.html","hash":"1f54f9a3cf08007a1e6088c0b013ecc8250835d9","modified":1531712439852},{"_id":"public/tags/ref/index.html","hash":"df3532c3b226aa489a09341f56b023de871c1e62","modified":1531712439852},{"_id":"public/2018/05/01/2018-05-02_ref_of_react/index.html","hash":"e5be8a0923e1ba390cf22922cfc02d17743c07aa","modified":1531712439853},{"_id":"public/2018/04/17/2018-04-17-css-vs-js-animation-performance/index.html","hash":"db1a2082aec648eb5f51be7fb0eff0e94cdcba03","modified":1531712439853},{"_id":"public/2017/05/02/2017-05-02_git_command/index.html","hash":"5b753b30ea0adfe376ecd3dd1b4e5c3cbec751f0","modified":1531712439853},{"_id":"public/index.html","hash":"028e9f48ceaef583519a4d584f64ffc708d2838f","modified":1531712439853},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1531711345549},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1531711345549},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1531711345549},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1531711345549},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1531711345550},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1531711345550},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1531711345550},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1531711345550},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1531711345550},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1531711345550},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1531711346068},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1531711346120},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1531711346120},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1531711346120},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1531711346121},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1531711346121},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1531711346121},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1531711346121},{"_id":"public/css/style.css","hash":"5f8dadd37d0052c557061018fe6f568f64fced9b","modified":1531711346121},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1531711346121},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1531711346121},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1531711346124},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1531711346125},{"_id":"source/_posts/2015-05-14-渐进增强与优雅降级.md","hash":"f152202c073c24fefe8442a4d4847a9965cb682e","modified":1531711523621},{"_id":"public/tags/Css/index.html","hash":"7306d3dbbb769d9a7a628b0c46bae094564618f6","modified":1531712439853},{"_id":"public/2018/04/14/2015-05-14-渐进增强与优雅降级/index.html","hash":"8490226c0a2ed195c0aec6aa236e89cbbf603f18","modified":1531712439849},{"_id":"source/_posts/2018-05-27-变量提升和函数提升.md","hash":"2b998c36a0715c5fcba4fd787e498fd80e3d5cda","modified":1531712416310},{"_id":"public/2018/05/27/2018-05-27-变量提升和函数提升/index.html","hash":"9fc23bebcb3056b340daba68495630514332608a","modified":1531712439857},{"_id":"public/archives/page/2/index.html","hash":"f75f54c636a1a9a4a2e09876e650fd07b5d14960","modified":1531712439857},{"_id":"public/page/2/index.html","hash":"6b1abfa0606321a8fccaa92786f7f234a23f68a0","modified":1531712439857}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Web前后端分离的意义","date":"2017-04-23T05:09:50.000Z","_content":"\n在此之前，我对于前后端分离的理解是：前后端只通过JSON来交流，组件化、工程化不需要依赖后端去实现。直到膜拜了知乎大神的解释，才对这一概念有了进一步的了解。\n\n<!-- more -->\n\n首先，前后端分离未必会具体到：\n> 前后端只通过JSON来交流，组件化、工程化不需要依赖后端去实现。\n\n这句话基于一个前提——以浏览器作为前后端的界定。但对于DOM量很大的网站来说，若以浏览器作为界定进行前后端的分离：使用js模板，然后在浏览器端执行，会有SEO不友好，首屏性能差的问题。对于这类网站得把关键模板放在服务器端来执行。譬如阿里，在服务器端引入Node层（node.js，对前端人员语言友好，前后端模板通用性）进行模板与数据的合成，生成HTML给浏览器。但还是会有一些内容需要在浏览器中用js去加载、生成。所以，这是一种混合方案，既有在服务器端执行的模板，也有在浏览器中执行的模板。对于这样的项目，前后端的分界一定要延伸到服务器端的模板层，也就是在这一层，把各种来源的数据整合到模板中，这个数据未必是JSON格式，也会存在XML、二进制等。\n\n再说组件化，上面这种组织形式较多应用于电商网站。像电商这种项目的前端部分，基本不存在组件的概念，甚至不存在组件化的价值，因为可服用的东西太少了，也不易提取，大多数东西都是不带逻辑的界面模板。\n\n接着前后端界限问题继续，上面提到前端的界定有可能会延伸到服务器端，前后端的分界相当模糊。Facebook就放弃了前后端的区分，而采用Product和Infrastructure的划分方式。做Product的通常都是Full Stack，不需要对特定的技术非常精通，但要求学习能力和灵活性足够好，不能只做自己Comfort Zone 以内的事情。通常聪明的应届生都会先进入 Product，因为他们学什么都很快，也不会说浪费了在某个领域的积累。Infrastructure拥有更多各个领域的 Specialist，前端只是其中之一。Infrastructure 的客户就是Product，要做的事情就是让Product 开发实际产品时更加便捷，就这么简单。另外，P/I与F/B并不是互斥的划分方案，本人在HP参与的SAW项目，就同时采用了这两种职能划分方式，既有Product与Infrastructure的划分：ess-saw与paas，Product又采用了前后端分离的开发模式：saw-ui与saw-server。\n\n回到问题本身，Web前后端分离的意义大吗？\n1. 该网站前端变化远比后端频繁，则意义大\n2. 改网站处于原始开发模式，数据逻辑与表现逻辑混杂不清，则意义大\n3. 该网站前端团队和后端团队分属两个领导班子，技能点差异很大，则意义大\n4. 该网站前端效果绚丽，跨设备兼容要求高，则意义大\n\n#### 参考\n\n[Web前后端分离的意义大吗？](https://www.zhihu.com/question/28207685)\n","source":"_posts/2017-04-23-front_Back_organization.md","raw":"---\ntitle: Web前后端分离的意义\ndate: 2017-4-23 13:09:50\ntags: [前端工程化, 前后端分离]\n---\n\n在此之前，我对于前后端分离的理解是：前后端只通过JSON来交流，组件化、工程化不需要依赖后端去实现。直到膜拜了知乎大神的解释，才对这一概念有了进一步的了解。\n\n<!-- more -->\n\n首先，前后端分离未必会具体到：\n> 前后端只通过JSON来交流，组件化、工程化不需要依赖后端去实现。\n\n这句话基于一个前提——以浏览器作为前后端的界定。但对于DOM量很大的网站来说，若以浏览器作为界定进行前后端的分离：使用js模板，然后在浏览器端执行，会有SEO不友好，首屏性能差的问题。对于这类网站得把关键模板放在服务器端来执行。譬如阿里，在服务器端引入Node层（node.js，对前端人员语言友好，前后端模板通用性）进行模板与数据的合成，生成HTML给浏览器。但还是会有一些内容需要在浏览器中用js去加载、生成。所以，这是一种混合方案，既有在服务器端执行的模板，也有在浏览器中执行的模板。对于这样的项目，前后端的分界一定要延伸到服务器端的模板层，也就是在这一层，把各种来源的数据整合到模板中，这个数据未必是JSON格式，也会存在XML、二进制等。\n\n再说组件化，上面这种组织形式较多应用于电商网站。像电商这种项目的前端部分，基本不存在组件的概念，甚至不存在组件化的价值，因为可服用的东西太少了，也不易提取，大多数东西都是不带逻辑的界面模板。\n\n接着前后端界限问题继续，上面提到前端的界定有可能会延伸到服务器端，前后端的分界相当模糊。Facebook就放弃了前后端的区分，而采用Product和Infrastructure的划分方式。做Product的通常都是Full Stack，不需要对特定的技术非常精通，但要求学习能力和灵活性足够好，不能只做自己Comfort Zone 以内的事情。通常聪明的应届生都会先进入 Product，因为他们学什么都很快，也不会说浪费了在某个领域的积累。Infrastructure拥有更多各个领域的 Specialist，前端只是其中之一。Infrastructure 的客户就是Product，要做的事情就是让Product 开发实际产品时更加便捷，就这么简单。另外，P/I与F/B并不是互斥的划分方案，本人在HP参与的SAW项目，就同时采用了这两种职能划分方式，既有Product与Infrastructure的划分：ess-saw与paas，Product又采用了前后端分离的开发模式：saw-ui与saw-server。\n\n回到问题本身，Web前后端分离的意义大吗？\n1. 该网站前端变化远比后端频繁，则意义大\n2. 改网站处于原始开发模式，数据逻辑与表现逻辑混杂不清，则意义大\n3. 该网站前端团队和后端团队分属两个领导班子，技能点差异很大，则意义大\n4. 该网站前端效果绚丽，跨设备兼容要求高，则意义大\n\n#### 参考\n\n[Web前后端分离的意义大吗？](https://www.zhihu.com/question/28207685)\n","slug":"2017-04-23-front_Back_organization","published":1,"updated":"2018-07-16T03:21:02.194Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjjnpdxp40000sdmn6l5pvzqx","content":"<p>在此之前，我对于前后端分离的理解是：前后端只通过JSON来交流，组件化、工程化不需要依赖后端去实现。直到膜拜了知乎大神的解释，才对这一概念有了进一步的了解。</p>\n<a id=\"more\"></a>\n<p>首先，前后端分离未必会具体到：</p>\n<blockquote>\n<p>前后端只通过JSON来交流，组件化、工程化不需要依赖后端去实现。</p>\n</blockquote>\n<p>这句话基于一个前提——以浏览器作为前后端的界定。但对于DOM量很大的网站来说，若以浏览器作为界定进行前后端的分离：使用js模板，然后在浏览器端执行，会有SEO不友好，首屏性能差的问题。对于这类网站得把关键模板放在服务器端来执行。譬如阿里，在服务器端引入Node层（node.js，对前端人员语言友好，前后端模板通用性）进行模板与数据的合成，生成HTML给浏览器。但还是会有一些内容需要在浏览器中用js去加载、生成。所以，这是一种混合方案，既有在服务器端执行的模板，也有在浏览器中执行的模板。对于这样的项目，前后端的分界一定要延伸到服务器端的模板层，也就是在这一层，把各种来源的数据整合到模板中，这个数据未必是JSON格式，也会存在XML、二进制等。</p>\n<p>再说组件化，上面这种组织形式较多应用于电商网站。像电商这种项目的前端部分，基本不存在组件的概念，甚至不存在组件化的价值，因为可服用的东西太少了，也不易提取，大多数东西都是不带逻辑的界面模板。</p>\n<p>接着前后端界限问题继续，上面提到前端的界定有可能会延伸到服务器端，前后端的分界相当模糊。Facebook就放弃了前后端的区分，而采用Product和Infrastructure的划分方式。做Product的通常都是Full Stack，不需要对特定的技术非常精通，但要求学习能力和灵活性足够好，不能只做自己Comfort Zone 以内的事情。通常聪明的应届生都会先进入 Product，因为他们学什么都很快，也不会说浪费了在某个领域的积累。Infrastructure拥有更多各个领域的 Specialist，前端只是其中之一。Infrastructure 的客户就是Product，要做的事情就是让Product 开发实际产品时更加便捷，就这么简单。另外，P/I与F/B并不是互斥的划分方案，本人在HP参与的SAW项目，就同时采用了这两种职能划分方式，既有Product与Infrastructure的划分：ess-saw与paas，Product又采用了前后端分离的开发模式：saw-ui与saw-server。</p>\n<p>回到问题本身，Web前后端分离的意义大吗？</p>\n<ol>\n<li>该网站前端变化远比后端频繁，则意义大</li>\n<li>改网站处于原始开发模式，数据逻辑与表现逻辑混杂不清，则意义大</li>\n<li>该网站前端团队和后端团队分属两个领导班子，技能点差异很大，则意义大</li>\n<li>该网站前端效果绚丽，跨设备兼容要求高，则意义大</li>\n</ol>\n<h4 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h4><p><a href=\"https://www.zhihu.com/question/28207685\" target=\"_blank\" rel=\"noopener\">Web前后端分离的意义大吗？</a></p>\n","site":{"data":{}},"excerpt":"<p>在此之前，我对于前后端分离的理解是：前后端只通过JSON来交流，组件化、工程化不需要依赖后端去实现。直到膜拜了知乎大神的解释，才对这一概念有了进一步的了解。</p>","more":"<p>首先，前后端分离未必会具体到：</p>\n<blockquote>\n<p>前后端只通过JSON来交流，组件化、工程化不需要依赖后端去实现。</p>\n</blockquote>\n<p>这句话基于一个前提——以浏览器作为前后端的界定。但对于DOM量很大的网站来说，若以浏览器作为界定进行前后端的分离：使用js模板，然后在浏览器端执行，会有SEO不友好，首屏性能差的问题。对于这类网站得把关键模板放在服务器端来执行。譬如阿里，在服务器端引入Node层（node.js，对前端人员语言友好，前后端模板通用性）进行模板与数据的合成，生成HTML给浏览器。但还是会有一些内容需要在浏览器中用js去加载、生成。所以，这是一种混合方案，既有在服务器端执行的模板，也有在浏览器中执行的模板。对于这样的项目，前后端的分界一定要延伸到服务器端的模板层，也就是在这一层，把各种来源的数据整合到模板中，这个数据未必是JSON格式，也会存在XML、二进制等。</p>\n<p>再说组件化，上面这种组织形式较多应用于电商网站。像电商这种项目的前端部分，基本不存在组件的概念，甚至不存在组件化的价值，因为可服用的东西太少了，也不易提取，大多数东西都是不带逻辑的界面模板。</p>\n<p>接着前后端界限问题继续，上面提到前端的界定有可能会延伸到服务器端，前后端的分界相当模糊。Facebook就放弃了前后端的区分，而采用Product和Infrastructure的划分方式。做Product的通常都是Full Stack，不需要对特定的技术非常精通，但要求学习能力和灵活性足够好，不能只做自己Comfort Zone 以内的事情。通常聪明的应届生都会先进入 Product，因为他们学什么都很快，也不会说浪费了在某个领域的积累。Infrastructure拥有更多各个领域的 Specialist，前端只是其中之一。Infrastructure 的客户就是Product，要做的事情就是让Product 开发实际产品时更加便捷，就这么简单。另外，P/I与F/B并不是互斥的划分方案，本人在HP参与的SAW项目，就同时采用了这两种职能划分方式，既有Product与Infrastructure的划分：ess-saw与paas，Product又采用了前后端分离的开发模式：saw-ui与saw-server。</p>\n<p>回到问题本身，Web前后端分离的意义大吗？</p>\n<ol>\n<li>该网站前端变化远比后端频繁，则意义大</li>\n<li>改网站处于原始开发模式，数据逻辑与表现逻辑混杂不清，则意义大</li>\n<li>该网站前端团队和后端团队分属两个领导班子，技能点差异很大，则意义大</li>\n<li>该网站前端效果绚丽，跨设备兼容要求高，则意义大</li>\n</ol>\n<h4 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h4><p><a href=\"https://www.zhihu.com/question/28207685\" target=\"_blank\" rel=\"noopener\">Web前后端分离的意义大吗？</a></p>"},{"title":"常用Git命令","date":"2017-05-02T01:38:11.000Z","_content":"\n[TOC]\n\n# 新建一个本地代码仓库，并上传到github\n\n1. 建立本地仓库\n```\ngit init\n```\n2. 把文件添加到版本库中，使用命令 git add .添加到暂存区里面去，不要忘记后面的小数点“.”，意为添加文件夹下的所有文件(夹)\n```\ngit add .\n\ngit add <filename> <filename> ... <filename>\n```\n\n<!-- more -->\n\n3. commit到主分支\n```\ngit commit -m \"\"\n```\n4. 登录github，把本地仓库提交至远程仓库,接下来你要做的就是复制那个地址，然后你将本地仓库个远程仓库连接起来\n```\ngit remote add origin git@github.com:用户名/仓库名.git\n```\n5. 进行第一次提交\n```\ngit push -u origin master\n```\n\n**PS: 系统报“fatal: refusing to merge unrelated histories”解决方案**\n\n因为远端的仓库谢了License，是本地没有的内容，push之前要去先pull。但pull得时候被认为是两个不同的仓库（没有共同祖先），系统提示这个错误。\n\n可以在pull操作中添加--allow-unrelated-histories属性\n\n```\ngit pull origin master --allow-unrelated-histories\n```\n\n# git 查看/修改用户名、密码\n\n用户名和邮箱地址的作用\n\n用户名和邮箱地址是本地git客户端的一个变量，不随git库而改变。\n\n每次commit都会用用户名和邮箱纪录。\n\ngithub的contributions统计就是按邮箱来统计的。\n\n```\n// 查看用户名和邮箱地址：\ngit config user.name\ngit config user.email\n\n// 修改用户名和邮箱地址：\ngit config --global user.name \"username\"\ngit config --global user.email \"email\"\n```\n\n# 修改git已经commit的邮箱和用户名\n\n```\n// 获取需要修改的版本的commit号\ngit log\n\n// 前往版本进行修改\ngit reset -soft <commit号>\n\n// 修改信息\ngit commit --amend --author='用户名<邮箱>'\n\n// 提交修改\ngit push <remote名> <branch名>\n```\n\n# 跨分支提交代码\n\n```\ncherry-pick\n```\n\n# 创建分支\n\n```\ngit branch <分支名>\n```\n\n# 切换分支\n\n```\n// 方法一：该语句和上一个语句可以和起来用一个语句表示\ngit checkout -b <分支名>\n\n// 方法二\ngit checkout <分支名>\n```\n# 分支合并\n\n如果要将开发中的分支（develop），合并到稳定分支（master）\n\n1. 首先切换的master分支\n```\ngit checkout master\n```\n2. 然后执行合并操作\n```\ngit merge develop\n```\n3. 如果有冲突会提示，查看冲突文件\n```\ngit status\n```\n4. 解决冲突，然后调用git add或git rm将解决后的文件暂存\n5. 所有冲突解决后，git commit 提交更改。\n\n# 分支衍合\n\n分支衍合和分支合并的差别在于，分支衍合不会保留合并的日志，不留痕迹，而 分支合并则会保留合并的日志。要将开发中的分支（develop），衍合到稳定分支（master）。\n\n1. 切换的master分支\n```\ngit checkout master\n```\n2. 后执行衍和操作\n```\ngit rebase develop\n```\n3. 如果有冲突会提示，查看冲突文件\n```\ngit status\n```\n4. 解决冲突，然后调用git add或git rm将解决后的文件暂存。\n5. 所有冲突解决后，git rebase --continue 提交更改。\n\n# 删除分支\n\n1. git branch -d <分支名>\n2. 如果该分支没有合并到主分支会报错，可以用以下命令强制删除\n```\ngit branch -D <分支名>\n```\n\n# 撤销add操作\n\n```\n// 撤销所有文件的add操作\ngit reset HEAD .\n// 撤销某个文件的add操作\ngit reset HEAD <文件名>\n```\n\n# 强行覆盖本地代码\n\n```\ngit fetch --all\ngit reset --hard origin/master\ngit pull\n```\n\n# 强行覆盖远端代码\n\n```\ngit push [远端名] [分支名] --force\n```\n\n# 远端代码强行覆盖本地代码\n\n```git\ngit fetch --all     // 下载远端仓库\ngit reset --hard origin/master      // 把HEAD指向刚刚下载的最新版本\n```\n","source":"_posts/2017-05-02_git_command.md","raw":"---\ntitle: 常用Git命令\ndate: 2017-5-2 09:38:11\ntags: [Git]\n---\n\n[TOC]\n\n# 新建一个本地代码仓库，并上传到github\n\n1. 建立本地仓库\n```\ngit init\n```\n2. 把文件添加到版本库中，使用命令 git add .添加到暂存区里面去，不要忘记后面的小数点“.”，意为添加文件夹下的所有文件(夹)\n```\ngit add .\n\ngit add <filename> <filename> ... <filename>\n```\n\n<!-- more -->\n\n3. commit到主分支\n```\ngit commit -m \"\"\n```\n4. 登录github，把本地仓库提交至远程仓库,接下来你要做的就是复制那个地址，然后你将本地仓库个远程仓库连接起来\n```\ngit remote add origin git@github.com:用户名/仓库名.git\n```\n5. 进行第一次提交\n```\ngit push -u origin master\n```\n\n**PS: 系统报“fatal: refusing to merge unrelated histories”解决方案**\n\n因为远端的仓库谢了License，是本地没有的内容，push之前要去先pull。但pull得时候被认为是两个不同的仓库（没有共同祖先），系统提示这个错误。\n\n可以在pull操作中添加--allow-unrelated-histories属性\n\n```\ngit pull origin master --allow-unrelated-histories\n```\n\n# git 查看/修改用户名、密码\n\n用户名和邮箱地址的作用\n\n用户名和邮箱地址是本地git客户端的一个变量，不随git库而改变。\n\n每次commit都会用用户名和邮箱纪录。\n\ngithub的contributions统计就是按邮箱来统计的。\n\n```\n// 查看用户名和邮箱地址：\ngit config user.name\ngit config user.email\n\n// 修改用户名和邮箱地址：\ngit config --global user.name \"username\"\ngit config --global user.email \"email\"\n```\n\n# 修改git已经commit的邮箱和用户名\n\n```\n// 获取需要修改的版本的commit号\ngit log\n\n// 前往版本进行修改\ngit reset -soft <commit号>\n\n// 修改信息\ngit commit --amend --author='用户名<邮箱>'\n\n// 提交修改\ngit push <remote名> <branch名>\n```\n\n# 跨分支提交代码\n\n```\ncherry-pick\n```\n\n# 创建分支\n\n```\ngit branch <分支名>\n```\n\n# 切换分支\n\n```\n// 方法一：该语句和上一个语句可以和起来用一个语句表示\ngit checkout -b <分支名>\n\n// 方法二\ngit checkout <分支名>\n```\n# 分支合并\n\n如果要将开发中的分支（develop），合并到稳定分支（master）\n\n1. 首先切换的master分支\n```\ngit checkout master\n```\n2. 然后执行合并操作\n```\ngit merge develop\n```\n3. 如果有冲突会提示，查看冲突文件\n```\ngit status\n```\n4. 解决冲突，然后调用git add或git rm将解决后的文件暂存\n5. 所有冲突解决后，git commit 提交更改。\n\n# 分支衍合\n\n分支衍合和分支合并的差别在于，分支衍合不会保留合并的日志，不留痕迹，而 分支合并则会保留合并的日志。要将开发中的分支（develop），衍合到稳定分支（master）。\n\n1. 切换的master分支\n```\ngit checkout master\n```\n2. 后执行衍和操作\n```\ngit rebase develop\n```\n3. 如果有冲突会提示，查看冲突文件\n```\ngit status\n```\n4. 解决冲突，然后调用git add或git rm将解决后的文件暂存。\n5. 所有冲突解决后，git rebase --continue 提交更改。\n\n# 删除分支\n\n1. git branch -d <分支名>\n2. 如果该分支没有合并到主分支会报错，可以用以下命令强制删除\n```\ngit branch -D <分支名>\n```\n\n# 撤销add操作\n\n```\n// 撤销所有文件的add操作\ngit reset HEAD .\n// 撤销某个文件的add操作\ngit reset HEAD <文件名>\n```\n\n# 强行覆盖本地代码\n\n```\ngit fetch --all\ngit reset --hard origin/master\ngit pull\n```\n\n# 强行覆盖远端代码\n\n```\ngit push [远端名] [分支名] --force\n```\n\n# 远端代码强行覆盖本地代码\n\n```git\ngit fetch --all     // 下载远端仓库\ngit reset --hard origin/master      // 把HEAD指向刚刚下载的最新版本\n```\n","slug":"2017-05-02_git_command","published":1,"updated":"2018-07-16T03:21:02.194Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjjnpdxpb0001sdmnxe1g4bo6","content":"<p>[TOC]</p>\n<h1 id=\"新建一个本地代码仓库，并上传到github\"><a href=\"#新建一个本地代码仓库，并上传到github\" class=\"headerlink\" title=\"新建一个本地代码仓库，并上传到github\"></a>新建一个本地代码仓库，并上传到github</h1><ol>\n<li><p>建立本地仓库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>把文件添加到版本库中，使用命令 git add .添加到暂存区里面去，不要忘记后面的小数点“.”，意为添加文件夹下的所有文件(夹)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\"></span><br><span class=\"line\">git add &lt;filename&gt; &lt;filename&gt; ... &lt;filename&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<a id=\"more\"></a>\n<ol start=\"3\">\n<li><p>commit到主分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;&quot;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>登录github，把本地仓库提交至远程仓库,接下来你要做的就是复制那个地址，然后你将本地仓库个远程仓库连接起来</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin git@github.com:用户名/仓库名.git</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>进行第一次提交</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><strong>PS: 系统报“fatal: refusing to merge unrelated histories”解决方案</strong></p>\n<p>因为远端的仓库谢了License，是本地没有的内容，push之前要去先pull。但pull得时候被认为是两个不同的仓库（没有共同祖先），系统提示这个错误。</p>\n<p>可以在pull操作中添加–allow-unrelated-histories属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure>\n<h1 id=\"git-查看-修改用户名、密码\"><a href=\"#git-查看-修改用户名、密码\" class=\"headerlink\" title=\"git 查看/修改用户名、密码\"></a>git 查看/修改用户名、密码</h1><p>用户名和邮箱地址的作用</p>\n<p>用户名和邮箱地址是本地git客户端的一个变量，不随git库而改变。</p>\n<p>每次commit都会用用户名和邮箱纪录。</p>\n<p>github的contributions统计就是按邮箱来统计的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 查看用户名和邮箱地址：</span><br><span class=\"line\">git config user.name</span><br><span class=\"line\">git config user.email</span><br><span class=\"line\"></span><br><span class=\"line\">// 修改用户名和邮箱地址：</span><br><span class=\"line\">git config --global user.name &quot;username&quot;</span><br><span class=\"line\">git config --global user.email &quot;email&quot;</span><br></pre></td></tr></table></figure>\n<h1 id=\"修改git已经commit的邮箱和用户名\"><a href=\"#修改git已经commit的邮箱和用户名\" class=\"headerlink\" title=\"修改git已经commit的邮箱和用户名\"></a>修改git已经commit的邮箱和用户名</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 获取需要修改的版本的commit号</span><br><span class=\"line\">git log</span><br><span class=\"line\"></span><br><span class=\"line\">// 前往版本进行修改</span><br><span class=\"line\">git reset -soft &lt;commit号&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 修改信息</span><br><span class=\"line\">git commit --amend --author=&apos;用户名&lt;邮箱&gt;&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">// 提交修改</span><br><span class=\"line\">git push &lt;remote名&gt; &lt;branch名&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"跨分支提交代码\"><a href=\"#跨分支提交代码\" class=\"headerlink\" title=\"跨分支提交代码\"></a>跨分支提交代码</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cherry-pick</span><br></pre></td></tr></table></figure>\n<h1 id=\"创建分支\"><a href=\"#创建分支\" class=\"headerlink\" title=\"创建分支\"></a>创建分支</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch &lt;分支名&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"切换分支\"><a href=\"#切换分支\" class=\"headerlink\" title=\"切换分支\"></a>切换分支</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 方法一：该语句和上一个语句可以和起来用一个语句表示</span><br><span class=\"line\">git checkout -b &lt;分支名&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 方法二</span><br><span class=\"line\">git checkout &lt;分支名&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"分支合并\"><a href=\"#分支合并\" class=\"headerlink\" title=\"分支合并\"></a>分支合并</h1><p>如果要将开发中的分支（develop），合并到稳定分支（master）</p>\n<ol>\n<li><p>首先切换的master分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout master</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>然后执行合并操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge develop</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果有冲突会提示，查看冲突文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git status</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>解决冲突，然后调用git add或git rm将解决后的文件暂存</p>\n</li>\n<li>所有冲突解决后，git commit 提交更改。</li>\n</ol>\n<h1 id=\"分支衍合\"><a href=\"#分支衍合\" class=\"headerlink\" title=\"分支衍合\"></a>分支衍合</h1><p>分支衍合和分支合并的差别在于，分支衍合不会保留合并的日志，不留痕迹，而 分支合并则会保留合并的日志。要将开发中的分支（develop），衍合到稳定分支（master）。</p>\n<ol>\n<li><p>切换的master分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout master</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>后执行衍和操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase develop</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果有冲突会提示，查看冲突文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git status</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>解决冲突，然后调用git add或git rm将解决后的文件暂存。</p>\n</li>\n<li>所有冲突解决后，git rebase –continue 提交更改。</li>\n</ol>\n<h1 id=\"删除分支\"><a href=\"#删除分支\" class=\"headerlink\" title=\"删除分支\"></a>删除分支</h1><ol>\n<li>git branch -d &lt;分支名&gt;</li>\n<li>如果该分支没有合并到主分支会报错，可以用以下命令强制删除<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -D &lt;分支名&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"撤销add操作\"><a href=\"#撤销add操作\" class=\"headerlink\" title=\"撤销add操作\"></a>撤销add操作</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 撤销所有文件的add操作</span><br><span class=\"line\">git reset HEAD .</span><br><span class=\"line\">// 撤销某个文件的add操作</span><br><span class=\"line\">git reset HEAD &lt;文件名&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"强行覆盖本地代码\"><a href=\"#强行覆盖本地代码\" class=\"headerlink\" title=\"强行覆盖本地代码\"></a>强行覆盖本地代码</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git fetch --all</span><br><span class=\"line\">git reset --hard origin/master</span><br><span class=\"line\">git pull</span><br></pre></td></tr></table></figure>\n<h1 id=\"强行覆盖远端代码\"><a href=\"#强行覆盖远端代码\" class=\"headerlink\" title=\"强行覆盖远端代码\"></a>强行覆盖远端代码</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push [远端名] [分支名] --force</span><br></pre></td></tr></table></figure>\n<h1 id=\"远端代码强行覆盖本地代码\"><a href=\"#远端代码强行覆盖本地代码\" class=\"headerlink\" title=\"远端代码强行覆盖本地代码\"></a>远端代码强行覆盖本地代码</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git fetch --all     // 下载远端仓库</span><br><span class=\"line\">git reset --hard origin/master      // 把HEAD指向刚刚下载的最新版本</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>[TOC]</p>\n<h1 id=\"新建一个本地代码仓库，并上传到github\"><a href=\"#新建一个本地代码仓库，并上传到github\" class=\"headerlink\" title=\"新建一个本地代码仓库，并上传到github\"></a>新建一个本地代码仓库，并上传到github</h1><ol>\n<li><p>建立本地仓库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>把文件添加到版本库中，使用命令 git add .添加到暂存区里面去，不要忘记后面的小数点“.”，意为添加文件夹下的所有文件(夹)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\"></span><br><span class=\"line\">git add &lt;filename&gt; &lt;filename&gt; ... &lt;filename&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>","more":"<ol start=\"3\">\n<li><p>commit到主分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;&quot;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>登录github，把本地仓库提交至远程仓库,接下来你要做的就是复制那个地址，然后你将本地仓库个远程仓库连接起来</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin git@github.com:用户名/仓库名.git</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>进行第一次提交</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><strong>PS: 系统报“fatal: refusing to merge unrelated histories”解决方案</strong></p>\n<p>因为远端的仓库谢了License，是本地没有的内容，push之前要去先pull。但pull得时候被认为是两个不同的仓库（没有共同祖先），系统提示这个错误。</p>\n<p>可以在pull操作中添加–allow-unrelated-histories属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure>\n<h1 id=\"git-查看-修改用户名、密码\"><a href=\"#git-查看-修改用户名、密码\" class=\"headerlink\" title=\"git 查看/修改用户名、密码\"></a>git 查看/修改用户名、密码</h1><p>用户名和邮箱地址的作用</p>\n<p>用户名和邮箱地址是本地git客户端的一个变量，不随git库而改变。</p>\n<p>每次commit都会用用户名和邮箱纪录。</p>\n<p>github的contributions统计就是按邮箱来统计的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 查看用户名和邮箱地址：</span><br><span class=\"line\">git config user.name</span><br><span class=\"line\">git config user.email</span><br><span class=\"line\"></span><br><span class=\"line\">// 修改用户名和邮箱地址：</span><br><span class=\"line\">git config --global user.name &quot;username&quot;</span><br><span class=\"line\">git config --global user.email &quot;email&quot;</span><br></pre></td></tr></table></figure>\n<h1 id=\"修改git已经commit的邮箱和用户名\"><a href=\"#修改git已经commit的邮箱和用户名\" class=\"headerlink\" title=\"修改git已经commit的邮箱和用户名\"></a>修改git已经commit的邮箱和用户名</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 获取需要修改的版本的commit号</span><br><span class=\"line\">git log</span><br><span class=\"line\"></span><br><span class=\"line\">// 前往版本进行修改</span><br><span class=\"line\">git reset -soft &lt;commit号&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 修改信息</span><br><span class=\"line\">git commit --amend --author=&apos;用户名&lt;邮箱&gt;&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">// 提交修改</span><br><span class=\"line\">git push &lt;remote名&gt; &lt;branch名&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"跨分支提交代码\"><a href=\"#跨分支提交代码\" class=\"headerlink\" title=\"跨分支提交代码\"></a>跨分支提交代码</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cherry-pick</span><br></pre></td></tr></table></figure>\n<h1 id=\"创建分支\"><a href=\"#创建分支\" class=\"headerlink\" title=\"创建分支\"></a>创建分支</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch &lt;分支名&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"切换分支\"><a href=\"#切换分支\" class=\"headerlink\" title=\"切换分支\"></a>切换分支</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 方法一：该语句和上一个语句可以和起来用一个语句表示</span><br><span class=\"line\">git checkout -b &lt;分支名&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 方法二</span><br><span class=\"line\">git checkout &lt;分支名&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"分支合并\"><a href=\"#分支合并\" class=\"headerlink\" title=\"分支合并\"></a>分支合并</h1><p>如果要将开发中的分支（develop），合并到稳定分支（master）</p>\n<ol>\n<li><p>首先切换的master分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout master</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>然后执行合并操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge develop</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果有冲突会提示，查看冲突文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git status</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>解决冲突，然后调用git add或git rm将解决后的文件暂存</p>\n</li>\n<li>所有冲突解决后，git commit 提交更改。</li>\n</ol>\n<h1 id=\"分支衍合\"><a href=\"#分支衍合\" class=\"headerlink\" title=\"分支衍合\"></a>分支衍合</h1><p>分支衍合和分支合并的差别在于，分支衍合不会保留合并的日志，不留痕迹，而 分支合并则会保留合并的日志。要将开发中的分支（develop），衍合到稳定分支（master）。</p>\n<ol>\n<li><p>切换的master分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout master</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>后执行衍和操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase develop</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果有冲突会提示，查看冲突文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git status</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>解决冲突，然后调用git add或git rm将解决后的文件暂存。</p>\n</li>\n<li>所有冲突解决后，git rebase –continue 提交更改。</li>\n</ol>\n<h1 id=\"删除分支\"><a href=\"#删除分支\" class=\"headerlink\" title=\"删除分支\"></a>删除分支</h1><ol>\n<li>git branch -d &lt;分支名&gt;</li>\n<li>如果该分支没有合并到主分支会报错，可以用以下命令强制删除<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -D &lt;分支名&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"撤销add操作\"><a href=\"#撤销add操作\" class=\"headerlink\" title=\"撤销add操作\"></a>撤销add操作</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 撤销所有文件的add操作</span><br><span class=\"line\">git reset HEAD .</span><br><span class=\"line\">// 撤销某个文件的add操作</span><br><span class=\"line\">git reset HEAD &lt;文件名&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"强行覆盖本地代码\"><a href=\"#强行覆盖本地代码\" class=\"headerlink\" title=\"强行覆盖本地代码\"></a>强行覆盖本地代码</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git fetch --all</span><br><span class=\"line\">git reset --hard origin/master</span><br><span class=\"line\">git pull</span><br></pre></td></tr></table></figure>\n<h1 id=\"强行覆盖远端代码\"><a href=\"#强行覆盖远端代码\" class=\"headerlink\" title=\"强行覆盖远端代码\"></a>强行覆盖远端代码</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push [远端名] [分支名] --force</span><br></pre></td></tr></table></figure>\n<h1 id=\"远端代码强行覆盖本地代码\"><a href=\"#远端代码强行覆盖本地代码\" class=\"headerlink\" title=\"远端代码强行覆盖本地代码\"></a>远端代码强行覆盖本地代码</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git fetch --all     // 下载远端仓库</span><br><span class=\"line\">git reset --hard origin/master      // 把HEAD指向刚刚下载的最新版本</span><br></pre></td></tr></table></figure>"},{"title":"前端架构是什么","date":"2017-12-08T13:22:15.000Z","_content":"\n架构是一个演变的过程。\n它指的不是随着历史的演变，而是随着项目演变。\n通常说架构，指的是架构模式，自创的架构很少。\n了解架构模式，才能心有余力的应对项目的发展。\n前端项目大概会经历以下这些阶段：\n1. 整体渲染\n2. 结构行为表现分离\n3. 隔离逻辑单元\n4. 插件\n5. 模块\n6. 前端MVC/MVVM\n7. 组件\n\n---\n\n### 整体渲染\n\n所有页面代码放到了一个html文档中，适合个人实验室项目。\n新建一个文件，快速的验证某个功能或者开发某个组件，再移植到开发环境中。\n优点：开发速度快，执行过程清晰\n不足：不容易分工合作\n\n### 结构行为表现分离\n\n当页面中有了好几个Script和Style片段，这时候就想着是不是该把它们放到一个文件中了。\n不然总在一个页面拖上拖下的改动太麻烦了。\n结构：HTML\n行为：JavaScript\n表现：CSS\n优点：关注点分离\n不足：职责不明确\n\n### 隔离逻辑单元\n\n一个JavaScript文件太大了，里面包含了很多不同的逻辑功能。\n还是把独立的功能提取出来吧，这样省的每次都在一个文件中改。\n优点：面向复用\n不足：功能点分散\n\n### 插件\n\n开闭原则：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。\n这让我想起了小时候的红白机。\n这个借鉴了微内核架构的思想，整个网站由一个很小的核心构成，所有功能都是嫁接上去的。\n这样核心基本上稳定了，只剩下增量的插件开发。\n优点：对需求的响应快\n不足：插件难以规范化\n\n### 模块\n\n当网站有了很多种独立的部分，微内核已经不能胜任了，因为各个插件之间产生了关联。\n就需要一个处理模块依赖的东西出现。\n于是人们定义了模块规范，分别有自己的处理模块依赖的办法。\n主要以下几种模块规范：\n\n（1）AMD规范（用户客户端，RequireJS实现）\n\n（2）CommonJS规范（用于服务端，Browserify实现）\n\n（3）EcmaScript 6 Module\n\n### 前端MVC/MVVM\n\n不止后端有MVC/MVVM，同样的思想也可以用在前端，并且人们已经实现了。\n主要目的是为了处理复杂的单页面应用，让三个层面独立开发，减轻脑力负担。\n\n- View：用户界面\n- Model：数据表的实体类\n- Controller/ViewModel：处理View和Model之间的关系\n主要实现有以下几个：\n\n    1. Backbone\n    2. Knockout\n    3. AngularJS\n\n### 组件\n\n组件并不是一个新兴的概念，但是React.js强制组件化，所以看来才那么新颖。\n它把JavaScript，CSS，HTML重新打包，当做一个逻辑单元来看待。\n有点像中国古代的“活字印刷”，不是吗，我们祖先的智慧啊。\n单一职责原则：一个类应该只有一个发生变化的原因。\n组合/聚集复用原则：尽量使用合成/聚合，而不是使用继承。\n\n---\n\n一个软件项目，随着待解决业务问题的发展，和问题复杂度的不同，会存在以下几个阶段，\n1. 具体解决方案\n2. 共用代码\n3. 功能独立的工具\n4. 架构模式\n5. 领域特定语言（DSL\n前文提到的，\n整体渲染是一种具体的解决方案，\n结构行为表现分离，是为了共用代码，\n隔离逻辑单元，目的是提取出功能独立的工具，\n插件（微内核），模块（分层?），MVC/MVVM，组件（微服务），属于不同的软件架构模式，\nJSX，TypeScript，Elm可以看做领域特定语言。\n根据具体的项目情况，项目组的的人员安排，\n架构师会选出当前适用的阶段，并规划出未来的发展方向。\n\n---\n\n为什么人们都在议论组件？\n是因为组件有助于降低业务代码的复杂度。\n组件是一种可拼装的功能集，业务代码只需要解决拼装问题，\n通过组件的再组合，就会不断增加细节的粒度，使业务逻辑更清晰。\nReact作为纯净的View层，为什么会成功？\nReact率先隔离了数据流和对数据的展示两个部分，\n这不但让数据有了不同形式的展示方式（React Native\n而且还加快了数据流引擎的更新换代。\n无论是事件驱动的Flux，还是基于状态机的Redux，都是具体的不同实现。\n加上响应式编程在背后的推动，View层的分离会让事情变得更美好。\n为什么Angular会拥抱TypeScript？\n使用动态弱类型的语言JavaScript，软件规模增加会导致很多意料之外的运行时错误，\n诚然，对软件进行测试可以减少故障，根据哥德尔不完备性定理也离不开测试。\n可是提高类型系统的安全性和可靠性，也是人们喜闻乐见的事情。\n无论是Flow，还是TypeScript，都是一种尝试\n\n","source":"_posts/2017-12-08_前端架构.md","raw":"---\ntitle: 前端架构是什么\ndate: 2017-12-8 21:22:15\ntags: [前端架构]\n---\n\n架构是一个演变的过程。\n它指的不是随着历史的演变，而是随着项目演变。\n通常说架构，指的是架构模式，自创的架构很少。\n了解架构模式，才能心有余力的应对项目的发展。\n前端项目大概会经历以下这些阶段：\n1. 整体渲染\n2. 结构行为表现分离\n3. 隔离逻辑单元\n4. 插件\n5. 模块\n6. 前端MVC/MVVM\n7. 组件\n\n---\n\n### 整体渲染\n\n所有页面代码放到了一个html文档中，适合个人实验室项目。\n新建一个文件，快速的验证某个功能或者开发某个组件，再移植到开发环境中。\n优点：开发速度快，执行过程清晰\n不足：不容易分工合作\n\n### 结构行为表现分离\n\n当页面中有了好几个Script和Style片段，这时候就想着是不是该把它们放到一个文件中了。\n不然总在一个页面拖上拖下的改动太麻烦了。\n结构：HTML\n行为：JavaScript\n表现：CSS\n优点：关注点分离\n不足：职责不明确\n\n### 隔离逻辑单元\n\n一个JavaScript文件太大了，里面包含了很多不同的逻辑功能。\n还是把独立的功能提取出来吧，这样省的每次都在一个文件中改。\n优点：面向复用\n不足：功能点分散\n\n### 插件\n\n开闭原则：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。\n这让我想起了小时候的红白机。\n这个借鉴了微内核架构的思想，整个网站由一个很小的核心构成，所有功能都是嫁接上去的。\n这样核心基本上稳定了，只剩下增量的插件开发。\n优点：对需求的响应快\n不足：插件难以规范化\n\n### 模块\n\n当网站有了很多种独立的部分，微内核已经不能胜任了，因为各个插件之间产生了关联。\n就需要一个处理模块依赖的东西出现。\n于是人们定义了模块规范，分别有自己的处理模块依赖的办法。\n主要以下几种模块规范：\n\n（1）AMD规范（用户客户端，RequireJS实现）\n\n（2）CommonJS规范（用于服务端，Browserify实现）\n\n（3）EcmaScript 6 Module\n\n### 前端MVC/MVVM\n\n不止后端有MVC/MVVM，同样的思想也可以用在前端，并且人们已经实现了。\n主要目的是为了处理复杂的单页面应用，让三个层面独立开发，减轻脑力负担。\n\n- View：用户界面\n- Model：数据表的实体类\n- Controller/ViewModel：处理View和Model之间的关系\n主要实现有以下几个：\n\n    1. Backbone\n    2. Knockout\n    3. AngularJS\n\n### 组件\n\n组件并不是一个新兴的概念，但是React.js强制组件化，所以看来才那么新颖。\n它把JavaScript，CSS，HTML重新打包，当做一个逻辑单元来看待。\n有点像中国古代的“活字印刷”，不是吗，我们祖先的智慧啊。\n单一职责原则：一个类应该只有一个发生变化的原因。\n组合/聚集复用原则：尽量使用合成/聚合，而不是使用继承。\n\n---\n\n一个软件项目，随着待解决业务问题的发展，和问题复杂度的不同，会存在以下几个阶段，\n1. 具体解决方案\n2. 共用代码\n3. 功能独立的工具\n4. 架构模式\n5. 领域特定语言（DSL\n前文提到的，\n整体渲染是一种具体的解决方案，\n结构行为表现分离，是为了共用代码，\n隔离逻辑单元，目的是提取出功能独立的工具，\n插件（微内核），模块（分层?），MVC/MVVM，组件（微服务），属于不同的软件架构模式，\nJSX，TypeScript，Elm可以看做领域特定语言。\n根据具体的项目情况，项目组的的人员安排，\n架构师会选出当前适用的阶段，并规划出未来的发展方向。\n\n---\n\n为什么人们都在议论组件？\n是因为组件有助于降低业务代码的复杂度。\n组件是一种可拼装的功能集，业务代码只需要解决拼装问题，\n通过组件的再组合，就会不断增加细节的粒度，使业务逻辑更清晰。\nReact作为纯净的View层，为什么会成功？\nReact率先隔离了数据流和对数据的展示两个部分，\n这不但让数据有了不同形式的展示方式（React Native\n而且还加快了数据流引擎的更新换代。\n无论是事件驱动的Flux，还是基于状态机的Redux，都是具体的不同实现。\n加上响应式编程在背后的推动，View层的分离会让事情变得更美好。\n为什么Angular会拥抱TypeScript？\n使用动态弱类型的语言JavaScript，软件规模增加会导致很多意料之外的运行时错误，\n诚然，对软件进行测试可以减少故障，根据哥德尔不完备性定理也离不开测试。\n可是提高类型系统的安全性和可靠性，也是人们喜闻乐见的事情。\n无论是Flow，还是TypeScript，都是一种尝试\n\n","slug":"2017-12-08_前端架构","published":1,"updated":"2018-07-16T03:21:02.194Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjjnpdxpf0003sdmn2c9p2p2i","content":"<p>架构是一个演变的过程。<br>它指的不是随着历史的演变，而是随着项目演变。<br>通常说架构，指的是架构模式，自创的架构很少。<br>了解架构模式，才能心有余力的应对项目的发展。<br>前端项目大概会经历以下这些阶段：</p>\n<ol>\n<li>整体渲染</li>\n<li>结构行为表现分离</li>\n<li>隔离逻辑单元</li>\n<li>插件</li>\n<li>模块</li>\n<li>前端MVC/MVVM</li>\n<li>组件</li>\n</ol>\n<hr>\n<h3 id=\"整体渲染\"><a href=\"#整体渲染\" class=\"headerlink\" title=\"整体渲染\"></a>整体渲染</h3><p>所有页面代码放到了一个html文档中，适合个人实验室项目。<br>新建一个文件，快速的验证某个功能或者开发某个组件，再移植到开发环境中。<br>优点：开发速度快，执行过程清晰<br>不足：不容易分工合作</p>\n<h3 id=\"结构行为表现分离\"><a href=\"#结构行为表现分离\" class=\"headerlink\" title=\"结构行为表现分离\"></a>结构行为表现分离</h3><p>当页面中有了好几个Script和Style片段，这时候就想着是不是该把它们放到一个文件中了。<br>不然总在一个页面拖上拖下的改动太麻烦了。<br>结构：HTML<br>行为：JavaScript<br>表现：CSS<br>优点：关注点分离<br>不足：职责不明确</p>\n<h3 id=\"隔离逻辑单元\"><a href=\"#隔离逻辑单元\" class=\"headerlink\" title=\"隔离逻辑单元\"></a>隔离逻辑单元</h3><p>一个JavaScript文件太大了，里面包含了很多不同的逻辑功能。<br>还是把独立的功能提取出来吧，这样省的每次都在一个文件中改。<br>优点：面向复用<br>不足：功能点分散</p>\n<h3 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h3><p>开闭原则：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。<br>这让我想起了小时候的红白机。<br>这个借鉴了微内核架构的思想，整个网站由一个很小的核心构成，所有功能都是嫁接上去的。<br>这样核心基本上稳定了，只剩下增量的插件开发。<br>优点：对需求的响应快<br>不足：插件难以规范化</p>\n<h3 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h3><p>当网站有了很多种独立的部分，微内核已经不能胜任了，因为各个插件之间产生了关联。<br>就需要一个处理模块依赖的东西出现。<br>于是人们定义了模块规范，分别有自己的处理模块依赖的办法。<br>主要以下几种模块规范：</p>\n<p>（1）AMD规范（用户客户端，RequireJS实现）</p>\n<p>（2）CommonJS规范（用于服务端，Browserify实现）</p>\n<p>（3）EcmaScript 6 Module</p>\n<h3 id=\"前端MVC-MVVM\"><a href=\"#前端MVC-MVVM\" class=\"headerlink\" title=\"前端MVC/MVVM\"></a>前端MVC/MVVM</h3><p>不止后端有MVC/MVVM，同样的思想也可以用在前端，并且人们已经实现了。<br>主要目的是为了处理复杂的单页面应用，让三个层面独立开发，减轻脑力负担。</p>\n<ul>\n<li>View：用户界面</li>\n<li>Model：数据表的实体类</li>\n<li><p>Controller/ViewModel：处理View和Model之间的关系<br>主要实现有以下几个：</p>\n<ol>\n<li>Backbone</li>\n<li>Knockout</li>\n<li>AngularJS</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h3><p>组件并不是一个新兴的概念，但是React.js强制组件化，所以看来才那么新颖。<br>它把JavaScript，CSS，HTML重新打包，当做一个逻辑单元来看待。<br>有点像中国古代的“活字印刷”，不是吗，我们祖先的智慧啊。<br>单一职责原则：一个类应该只有一个发生变化的原因。<br>组合/聚集复用原则：尽量使用合成/聚合，而不是使用继承。</p>\n<hr>\n<p>一个软件项目，随着待解决业务问题的发展，和问题复杂度的不同，会存在以下几个阶段，</p>\n<ol>\n<li>具体解决方案</li>\n<li>共用代码</li>\n<li>功能独立的工具</li>\n<li>架构模式</li>\n<li>领域特定语言（DSL<br>前文提到的，<br>整体渲染是一种具体的解决方案，<br>结构行为表现分离，是为了共用代码，<br>隔离逻辑单元，目的是提取出功能独立的工具，<br>插件（微内核），模块（分层?），MVC/MVVM，组件（微服务），属于不同的软件架构模式，<br>JSX，TypeScript，Elm可以看做领域特定语言。<br>根据具体的项目情况，项目组的的人员安排，<br>架构师会选出当前适用的阶段，并规划出未来的发展方向。</li>\n</ol>\n<hr>\n<p>为什么人们都在议论组件？<br>是因为组件有助于降低业务代码的复杂度。<br>组件是一种可拼装的功能集，业务代码只需要解决拼装问题，<br>通过组件的再组合，就会不断增加细节的粒度，使业务逻辑更清晰。<br>React作为纯净的View层，为什么会成功？<br>React率先隔离了数据流和对数据的展示两个部分，<br>这不但让数据有了不同形式的展示方式（React Native<br>而且还加快了数据流引擎的更新换代。<br>无论是事件驱动的Flux，还是基于状态机的Redux，都是具体的不同实现。<br>加上响应式编程在背后的推动，View层的分离会让事情变得更美好。<br>为什么Angular会拥抱TypeScript？<br>使用动态弱类型的语言JavaScript，软件规模增加会导致很多意料之外的运行时错误，<br>诚然，对软件进行测试可以减少故障，根据哥德尔不完备性定理也离不开测试。<br>可是提高类型系统的安全性和可靠性，也是人们喜闻乐见的事情。<br>无论是Flow，还是TypeScript，都是一种尝试</p>\n","site":{"data":{}},"excerpt":"","more":"<p>架构是一个演变的过程。<br>它指的不是随着历史的演变，而是随着项目演变。<br>通常说架构，指的是架构模式，自创的架构很少。<br>了解架构模式，才能心有余力的应对项目的发展。<br>前端项目大概会经历以下这些阶段：</p>\n<ol>\n<li>整体渲染</li>\n<li>结构行为表现分离</li>\n<li>隔离逻辑单元</li>\n<li>插件</li>\n<li>模块</li>\n<li>前端MVC/MVVM</li>\n<li>组件</li>\n</ol>\n<hr>\n<h3 id=\"整体渲染\"><a href=\"#整体渲染\" class=\"headerlink\" title=\"整体渲染\"></a>整体渲染</h3><p>所有页面代码放到了一个html文档中，适合个人实验室项目。<br>新建一个文件，快速的验证某个功能或者开发某个组件，再移植到开发环境中。<br>优点：开发速度快，执行过程清晰<br>不足：不容易分工合作</p>\n<h3 id=\"结构行为表现分离\"><a href=\"#结构行为表现分离\" class=\"headerlink\" title=\"结构行为表现分离\"></a>结构行为表现分离</h3><p>当页面中有了好几个Script和Style片段，这时候就想着是不是该把它们放到一个文件中了。<br>不然总在一个页面拖上拖下的改动太麻烦了。<br>结构：HTML<br>行为：JavaScript<br>表现：CSS<br>优点：关注点分离<br>不足：职责不明确</p>\n<h3 id=\"隔离逻辑单元\"><a href=\"#隔离逻辑单元\" class=\"headerlink\" title=\"隔离逻辑单元\"></a>隔离逻辑单元</h3><p>一个JavaScript文件太大了，里面包含了很多不同的逻辑功能。<br>还是把独立的功能提取出来吧，这样省的每次都在一个文件中改。<br>优点：面向复用<br>不足：功能点分散</p>\n<h3 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h3><p>开闭原则：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。<br>这让我想起了小时候的红白机。<br>这个借鉴了微内核架构的思想，整个网站由一个很小的核心构成，所有功能都是嫁接上去的。<br>这样核心基本上稳定了，只剩下增量的插件开发。<br>优点：对需求的响应快<br>不足：插件难以规范化</p>\n<h3 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h3><p>当网站有了很多种独立的部分，微内核已经不能胜任了，因为各个插件之间产生了关联。<br>就需要一个处理模块依赖的东西出现。<br>于是人们定义了模块规范，分别有自己的处理模块依赖的办法。<br>主要以下几种模块规范：</p>\n<p>（1）AMD规范（用户客户端，RequireJS实现）</p>\n<p>（2）CommonJS规范（用于服务端，Browserify实现）</p>\n<p>（3）EcmaScript 6 Module</p>\n<h3 id=\"前端MVC-MVVM\"><a href=\"#前端MVC-MVVM\" class=\"headerlink\" title=\"前端MVC/MVVM\"></a>前端MVC/MVVM</h3><p>不止后端有MVC/MVVM，同样的思想也可以用在前端，并且人们已经实现了。<br>主要目的是为了处理复杂的单页面应用，让三个层面独立开发，减轻脑力负担。</p>\n<ul>\n<li>View：用户界面</li>\n<li>Model：数据表的实体类</li>\n<li><p>Controller/ViewModel：处理View和Model之间的关系<br>主要实现有以下几个：</p>\n<ol>\n<li>Backbone</li>\n<li>Knockout</li>\n<li>AngularJS</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h3><p>组件并不是一个新兴的概念，但是React.js强制组件化，所以看来才那么新颖。<br>它把JavaScript，CSS，HTML重新打包，当做一个逻辑单元来看待。<br>有点像中国古代的“活字印刷”，不是吗，我们祖先的智慧啊。<br>单一职责原则：一个类应该只有一个发生变化的原因。<br>组合/聚集复用原则：尽量使用合成/聚合，而不是使用继承。</p>\n<hr>\n<p>一个软件项目，随着待解决业务问题的发展，和问题复杂度的不同，会存在以下几个阶段，</p>\n<ol>\n<li>具体解决方案</li>\n<li>共用代码</li>\n<li>功能独立的工具</li>\n<li>架构模式</li>\n<li>领域特定语言（DSL<br>前文提到的，<br>整体渲染是一种具体的解决方案，<br>结构行为表现分离，是为了共用代码，<br>隔离逻辑单元，目的是提取出功能独立的工具，<br>插件（微内核），模块（分层?），MVC/MVVM，组件（微服务），属于不同的软件架构模式，<br>JSX，TypeScript，Elm可以看做领域特定语言。<br>根据具体的项目情况，项目组的的人员安排，<br>架构师会选出当前适用的阶段，并规划出未来的发展方向。</li>\n</ol>\n<hr>\n<p>为什么人们都在议论组件？<br>是因为组件有助于降低业务代码的复杂度。<br>组件是一种可拼装的功能集，业务代码只需要解决拼装问题，<br>通过组件的再组合，就会不断增加细节的粒度，使业务逻辑更清晰。<br>React作为纯净的View层，为什么会成功？<br>React率先隔离了数据流和对数据的展示两个部分，<br>这不但让数据有了不同形式的展示方式（React Native<br>而且还加快了数据流引擎的更新换代。<br>无论是事件驱动的Flux，还是基于状态机的Redux，都是具体的不同实现。<br>加上响应式编程在背后的推动，View层的分离会让事情变得更美好。<br>为什么Angular会拥抱TypeScript？<br>使用动态弱类型的语言JavaScript，软件规模增加会导致很多意料之外的运行时错误，<br>诚然，对软件进行测试可以减少故障，根据哥德尔不完备性定理也离不开测试。<br>可是提高类型系统的安全性和可靠性，也是人们喜闻乐见的事情。<br>无论是Flow，还是TypeScript，都是一种尝试</p>\n"},{"title":"HTTP协议","date":"2018-02-01T12:22:15.000Z","_content":"\n### Web API文档工具列表\n- Swagger ——Swagger框架可以通过代码生成漂亮的在线API，甚至可以提供运行示例。支持Scala、Java、Javascript、Ruby、PHP甚至 Actionscript 3。在线 Demo 。\n- I/O Docs ——I/O Docs是一个用于RESTful Web APIs的交互式文档系统。使用 JSON 模型根据资源、方法和参数定义 APIs。I/O Docs 将生成 JavaScript 客户端接口，可通过这些接口来调用系统。服务器端基于 Node.js 开发。在线Demo\n- apiary.io ——能够快速启动和运行文档，包括GitHub集成和I/O验证——更多建议可以前往Reddit查看上关于 Siyfion讨论。\n- Docco ——Docco是一个快速而随意、hundred-line-long、迭代程序风格的文档生成器。它会以HTML的方式显示评论和代码。\n- Dexy ——非常灵活的一款文档工具，支持任何语言编写的API。\n- Doxygen ——Doxgen可以从一套归档源文件开始，生成HTML格式的在线类浏览器，或离线的LATEX、RTF参考手册。对于未归档的源文件，也可以通过配置Doxygen来提取代码结构。 更多建议可以前往Reddi上查看 gkumar007相关讨论。\n- TurnAPI ——是一款付费的文档API工具。里面包含了智能WIKI编辑器、基于标准的Markdown、文档分支、还可以与Git、SVN、Mercurial同步、整洁的主题、友好的界面。\n","source":"_posts/2018-02-01_API文档生成工具.md","raw":"---\ntitle: HTTP协议\ndate: 2018-2-1 20:22:15\ntags: [API, 工具]\n---\n\n### Web API文档工具列表\n- Swagger ——Swagger框架可以通过代码生成漂亮的在线API，甚至可以提供运行示例。支持Scala、Java、Javascript、Ruby、PHP甚至 Actionscript 3。在线 Demo 。\n- I/O Docs ——I/O Docs是一个用于RESTful Web APIs的交互式文档系统。使用 JSON 模型根据资源、方法和参数定义 APIs。I/O Docs 将生成 JavaScript 客户端接口，可通过这些接口来调用系统。服务器端基于 Node.js 开发。在线Demo\n- apiary.io ——能够快速启动和运行文档，包括GitHub集成和I/O验证——更多建议可以前往Reddit查看上关于 Siyfion讨论。\n- Docco ——Docco是一个快速而随意、hundred-line-long、迭代程序风格的文档生成器。它会以HTML的方式显示评论和代码。\n- Dexy ——非常灵活的一款文档工具，支持任何语言编写的API。\n- Doxygen ——Doxgen可以从一套归档源文件开始，生成HTML格式的在线类浏览器，或离线的LATEX、RTF参考手册。对于未归档的源文件，也可以通过配置Doxygen来提取代码结构。 更多建议可以前往Reddi上查看 gkumar007相关讨论。\n- TurnAPI ——是一款付费的文档API工具。里面包含了智能WIKI编辑器、基于标准的Markdown、文档分支、还可以与Git、SVN、Mercurial同步、整洁的主题、友好的界面。\n","slug":"2018-02-01_API文档生成工具","published":1,"updated":"2018-07-16T03:21:02.194Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjjnpdxph0004sdmnlrsqy3vn","content":"<h3 id=\"Web-API文档工具列表\"><a href=\"#Web-API文档工具列表\" class=\"headerlink\" title=\"Web API文档工具列表\"></a>Web API文档工具列表</h3><ul>\n<li>Swagger ——Swagger框架可以通过代码生成漂亮的在线API，甚至可以提供运行示例。支持Scala、Java、Javascript、Ruby、PHP甚至 Actionscript 3。在线 Demo 。</li>\n<li>I/O Docs ——I/O Docs是一个用于RESTful Web APIs的交互式文档系统。使用 JSON 模型根据资源、方法和参数定义 APIs。I/O Docs 将生成 JavaScript 客户端接口，可通过这些接口来调用系统。服务器端基于 Node.js 开发。在线Demo</li>\n<li>apiary.io ——能够快速启动和运行文档，包括GitHub集成和I/O验证——更多建议可以前往Reddit查看上关于 Siyfion讨论。</li>\n<li>Docco ——Docco是一个快速而随意、hundred-line-long、迭代程序风格的文档生成器。它会以HTML的方式显示评论和代码。</li>\n<li>Dexy ——非常灵活的一款文档工具，支持任何语言编写的API。</li>\n<li>Doxygen ——Doxgen可以从一套归档源文件开始，生成HTML格式的在线类浏览器，或离线的LATEX、RTF参考手册。对于未归档的源文件，也可以通过配置Doxygen来提取代码结构。 更多建议可以前往Reddi上查看 gkumar007相关讨论。</li>\n<li>TurnAPI ——是一款付费的文档API工具。里面包含了智能WIKI编辑器、基于标准的Markdown、文档分支、还可以与Git、SVN、Mercurial同步、整洁的主题、友好的界面。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Web-API文档工具列表\"><a href=\"#Web-API文档工具列表\" class=\"headerlink\" title=\"Web API文档工具列表\"></a>Web API文档工具列表</h3><ul>\n<li>Swagger ——Swagger框架可以通过代码生成漂亮的在线API，甚至可以提供运行示例。支持Scala、Java、Javascript、Ruby、PHP甚至 Actionscript 3。在线 Demo 。</li>\n<li>I/O Docs ——I/O Docs是一个用于RESTful Web APIs的交互式文档系统。使用 JSON 模型根据资源、方法和参数定义 APIs。I/O Docs 将生成 JavaScript 客户端接口，可通过这些接口来调用系统。服务器端基于 Node.js 开发。在线Demo</li>\n<li>apiary.io ——能够快速启动和运行文档，包括GitHub集成和I/O验证——更多建议可以前往Reddit查看上关于 Siyfion讨论。</li>\n<li>Docco ——Docco是一个快速而随意、hundred-line-long、迭代程序风格的文档生成器。它会以HTML的方式显示评论和代码。</li>\n<li>Dexy ——非常灵活的一款文档工具，支持任何语言编写的API。</li>\n<li>Doxygen ——Doxgen可以从一套归档源文件开始，生成HTML格式的在线类浏览器，或离线的LATEX、RTF参考手册。对于未归档的源文件，也可以通过配置Doxygen来提取代码结构。 更多建议可以前往Reddi上查看 gkumar007相关讨论。</li>\n<li>TurnAPI ——是一款付费的文档API工具。里面包含了智能WIKI编辑器、基于标准的Markdown、文档分支、还可以与Git、SVN、Mercurial同步、整洁的主题、友好的界面。</li>\n</ul>\n"},{"title":"HTTP协议","date":"2018-03-14T11:28:15.000Z","_content":"\n- [GET和POST的区别](https://www.zhihu.com/question/28586791)\n- [理解POST和PUT的区别，顺便提下RESTful](https://www.cnblogs.com/ximenxiazi/p/5850273.html)\n- [HTTP中post和put的根本区别和优势？](https://www.zhihu.com/question/48482736?from=profile_question_card)\n","source":"_posts/2018-03-14_http.md","raw":"---\ntitle: HTTP协议\ndate: 2018-3-14 19:28:15\ntags: [HTTP]\n---\n\n- [GET和POST的区别](https://www.zhihu.com/question/28586791)\n- [理解POST和PUT的区别，顺便提下RESTful](https://www.cnblogs.com/ximenxiazi/p/5850273.html)\n- [HTTP中post和put的根本区别和优势？](https://www.zhihu.com/question/48482736?from=profile_question_card)\n","slug":"2018-03-14_http","published":1,"updated":"2018-07-16T03:21:02.194Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjjnpdxpi0005sdmngtq1h5mc","content":"<ul>\n<li><a href=\"https://www.zhihu.com/question/28586791\" target=\"_blank\" rel=\"noopener\">GET和POST的区别</a></li>\n<li><a href=\"https://www.cnblogs.com/ximenxiazi/p/5850273.html\" target=\"_blank\" rel=\"noopener\">理解POST和PUT的区别，顺便提下RESTful</a></li>\n<li><a href=\"https://www.zhihu.com/question/48482736?from=profile_question_card\" target=\"_blank\" rel=\"noopener\">HTTP中post和put的根本区别和优势？</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><a href=\"https://www.zhihu.com/question/28586791\" target=\"_blank\" rel=\"noopener\">GET和POST的区别</a></li>\n<li><a href=\"https://www.cnblogs.com/ximenxiazi/p/5850273.html\" target=\"_blank\" rel=\"noopener\">理解POST和PUT的区别，顺便提下RESTful</a></li>\n<li><a href=\"https://www.zhihu.com/question/48482736?from=profile_question_card\" target=\"_blank\" rel=\"noopener\">HTTP中post和put的根本区别和优势？</a></li>\n</ul>\n"},{"title":"CSS vs JS动画，哪个更快","date":"2018-04-17T04:19:22.000Z","_content":"英文原文：https://davidwalsh.name/css-js-animation\n\n原作者Julian Shapiro是Velocity.js的作者，Velocity.js是一个高效易用的js动画库。在《Javascript网页动画设计》一书中对这个库有很多更具体的剖析.\n\n# JQuery\n\n Javascript 和 jQuery 两者不能错误的混为一谈。Javascript 动画很快，而 jQuery 动画却慢下来。为什么呢？因为尽管 jQuery 非常强大，但是它的设计目标并不是一个高效的动画引擎：\n\n<!-- more -->\n\n1. JQuery不能避免layout thrashing，由于它不仅仅要服务于动画，也需要用于其他场景。\n\n2. JQuery的内存消耗会频繁的触发垃圾回收机制，而垃圾回收会让动画暂时卡住。\n\n3. JQuery使用了setInterval而不是requestAnimationFrame(RAF)，为了避免RAF在失去焦点的时候停止动画(译者注：JQuery3.0集成了RAF，不支持IE8及以下版本了)。\n\n注意 layout thrashing 是导致动画在开始的时候卡顿的原因，垃圾回收是导致动画运行过程中的卡顿的原因，不使用 RAF 通常会导致动画帧率低。\n\n```\nvar currentTop, currentLeft;\n\n/* With layout thrashing. */\ncurrentTop = element.style.top; /* QUERY */\nelement.style.top = currentTop + 1; /* UPDATE */\n\ncurrentLeft = element.style.left; /* QUERY */\nelement.style.left = currentLeft + 1; /* UPDATE */\n\n/* Without layout thrashing. */\ncurrentTop = element.style.top; /* QUERY */\ncurrentLeft = element.style.left; /* QUERY */\n\nelement.style.top = currentTop + 1; /* UPDATE */\nelement.style.left = currentLeft + 1; /* UPDATE */\n```\n\n在更新操作之后的访问操作会强制浏览器重新计算页面元素的样式（因为要将更新的样式应用上去才能获取正确的值）。这个在一般操作下没太大的性能损失，但是放在间隔仅仅16ms的动画中则会导致显著的性能开销。只需要稍微改动下操作的顺序就可以大大提高动画的性能。\n\n类似地，使用 RAF 也不会迫使你大量重构现在的代码。让我们来比较下使用 RAF 和使用 setInterval 的区别：\n\n```\nvar startingTop = 0;\n\n/* setInterval: Runs every 16ms to achieve 60fps (1000ms/60 ~= 16ms). */\nsetInterval(function() {\n    /* Since this ticks 60 times a second, we divide the top property's increment of 1 unit per 1 second by 60. */\n    element.style.top = (startingTop += 1/60);\n}, 16);\n\n/* requestAnimationFrame: Attempts to run at 60fps based on whether the browser is in an optimal state. */\nfunction tick () {\n    element.style.top = (startingTop += 1/60);\n}\n\nwindow.requestAnimationFrame(tick);\n```\n\nRAF可以提供对动画性能最大可能的提升，而为此你只需要对你的代码进行一个简单的修改。\n\n# css Transitions\n\nCSS transition的性能能够比 jQuery 动画好，transition将动画逻辑抛给浏览器自身来执行。它的优势体现在：\n\n1.通过优化 DOM 操作和内存消耗来避免卡顿\n\n2.利用RAF底层的原理\n\n3.强制硬件加速（使用GPU加速来提高动画效果）。\n\n然而实际上Javascript可以直接使用这些优化。GSAP 已经做这些优化有些年头了。Velocity.js ，一个新的动画引擎，不仅仅实现了相同的技术，而且走的更远些。\n\n面对现实，让 Javascript 动画可以与 CSS 动画性能竞争只是我们复兴计划的第一步。第二步是意识到事实上 Javascript 动画比 CSS 动画快！\n\n让我们以测试CSS动画的缺陷开始吧：\n\n1.Transition的强制使用GPU加速，致使动画卡顿不流畅和高负荷下的束缚。这种情况在移动设备上会加剧发生。（特别需要说明的是，卡顿是由于当数据在浏览器的主线程和其排序线程之间传输的时候发生的过载引起的。一些CSS属性，例如transforms和opacity，不会受到这种限制。）Adobe兄弟的博客谈论过这个话题。\n\n2. Transition在IE10不会起作用，这使得很多桌面场景残留的IE8、IE9中会产生兼容问题。\n\n3. 由于Transition不能原生地被javascript控制（仅仅是被javascript触发），浏览器不知道如何去优化操作Transition的javascript代码。\n\n相反的，基于javascript的动画库可以自己决定什么时候启用硬件加速，他们很自然的在IE各版本下正常工作，而且他们也非常适合批量动画优化。\n\n我的建议是可以在专门为移动端开发的页面上使用原生的css Transitions,并且你的动画只由简单的状态变化组成。在这样的情况下，transitions是一个允许你把动画的逻辑全部保留在css样式表里面，不会因为使用太多javascript库导致页面膨胀的 高性能内嵌的方法。但是，你如果正在设计复杂的UI动画或者正开发一款多状态UI的APP，记得用动画库，以便你的动画处于高性能状态，你的工作流程处于易处理状态。\n\nJavaScript动画\n\njavascript在使用的时候性能是可以占优势的。但javascript究竟可以快多少？开始--快到足以建立一个对比强烈的3D演示动画，就像你想的那样，通常用webGl才能完成的。快到足以建立一个复杂的多媒体动画，通常使用Flash或After Effects才能完成的。\n\n快到可以构建一个虚拟世界，通常使用canvas才能完成的。\n\n为了直接比较主流的动画库的表现，包括Transit（它使用了CSS的Transition），可以在这里先看看Velocity的官方文档：VelocityJS.org\n\n之前的问题还在：javascript如何达到高性能的？\n\n下面列出了一些优化，javascript的动画库可以胜任的表现：\n\n1. 同步DOM->调整堆栈之间的动画链来最小化布局抖动。\n\n2. 在链式调用中缓存属性值来最小化DOM查询的发生（这就是高性能动画的阿喀琉斯之踵）。\n\n3. 当更新基本上看不出来时，跳过样式更新。\n\n可以重温下我们之前讨论过的布局抖动，velocity.js利用这些最佳实践，来缓存动画结束值，使其被重用为随后的动画的起始值。以此来避免再次查询DOM元素的起始值。\n\n ```\n$element\n/* Slide the element down into view. */\n.velocity({ opacity: 1, top: \"50%\" })\n/* After a delay of 1000ms, slide the element out of view. */\n.velocity({ opacity: 0, top: \"-50%\" }, { delay: 1000 });\n ```\n\n 在上面的例子中，第二次velocity调用时已经知道，应该在opacity为1，top为50%时自动开始。\n\n浏览器可以自身执行类似这样的优化，但是这样做会很大程度上限制开发者手工写动画代码的方法。\n\n因此，基于同样的原因，Jquery不用RAF（见上文），浏览器从不实行 可能会打破规范或者偏离预期行为的优化。\n\n最后，让我们来比较一下两个javascript动画库（velocity和GSAP）。\n\n1. GSAP是一个快速，功能丰富的动画库平台。velocity是一个大大提高UI动画性能和工作刘的轻量级的工具。\n\n2. GSAP对于种类繁多的商业应用需要付费，velocity是完全开源免费的，它使用了十分自由的MITlicence。\n\n3. 在实际应用中，两者的性能表现相当。\n\n我的建议是你需要精确控制时间的时候使用GSAP（例如：remapping,暂停\\继续\\跳过），移动（例如贝塞尔曲线），或者复杂的动画组合\\队列。这些特性对于游戏开发及一些特殊应用十分重要，但在web应用中不太常见。\n\nGSAP有着富特性功能，但不意味着Velocity自身功能不丰富。相反，在压缩之后7KB的包里面，Velocity不仅仅实现了Jqueryanimate的所有功能，也打包了色彩动画，变换，循环，移动，类动画，滚动。\n","source":"_posts/2018-04-17-css-vs-js-animation-performance.md","raw":"---\ntitle: CSS vs JS动画，哪个更快\ndate: 2018-4-17 12:19:22\ntags: [CSS, JavaScript, 前端动画]\n---\n英文原文：https://davidwalsh.name/css-js-animation\n\n原作者Julian Shapiro是Velocity.js的作者，Velocity.js是一个高效易用的js动画库。在《Javascript网页动画设计》一书中对这个库有很多更具体的剖析.\n\n# JQuery\n\n Javascript 和 jQuery 两者不能错误的混为一谈。Javascript 动画很快，而 jQuery 动画却慢下来。为什么呢？因为尽管 jQuery 非常强大，但是它的设计目标并不是一个高效的动画引擎：\n\n<!-- more -->\n\n1. JQuery不能避免layout thrashing，由于它不仅仅要服务于动画，也需要用于其他场景。\n\n2. JQuery的内存消耗会频繁的触发垃圾回收机制，而垃圾回收会让动画暂时卡住。\n\n3. JQuery使用了setInterval而不是requestAnimationFrame(RAF)，为了避免RAF在失去焦点的时候停止动画(译者注：JQuery3.0集成了RAF，不支持IE8及以下版本了)。\n\n注意 layout thrashing 是导致动画在开始的时候卡顿的原因，垃圾回收是导致动画运行过程中的卡顿的原因，不使用 RAF 通常会导致动画帧率低。\n\n```\nvar currentTop, currentLeft;\n\n/* With layout thrashing. */\ncurrentTop = element.style.top; /* QUERY */\nelement.style.top = currentTop + 1; /* UPDATE */\n\ncurrentLeft = element.style.left; /* QUERY */\nelement.style.left = currentLeft + 1; /* UPDATE */\n\n/* Without layout thrashing. */\ncurrentTop = element.style.top; /* QUERY */\ncurrentLeft = element.style.left; /* QUERY */\n\nelement.style.top = currentTop + 1; /* UPDATE */\nelement.style.left = currentLeft + 1; /* UPDATE */\n```\n\n在更新操作之后的访问操作会强制浏览器重新计算页面元素的样式（因为要将更新的样式应用上去才能获取正确的值）。这个在一般操作下没太大的性能损失，但是放在间隔仅仅16ms的动画中则会导致显著的性能开销。只需要稍微改动下操作的顺序就可以大大提高动画的性能。\n\n类似地，使用 RAF 也不会迫使你大量重构现在的代码。让我们来比较下使用 RAF 和使用 setInterval 的区别：\n\n```\nvar startingTop = 0;\n\n/* setInterval: Runs every 16ms to achieve 60fps (1000ms/60 ~= 16ms). */\nsetInterval(function() {\n    /* Since this ticks 60 times a second, we divide the top property's increment of 1 unit per 1 second by 60. */\n    element.style.top = (startingTop += 1/60);\n}, 16);\n\n/* requestAnimationFrame: Attempts to run at 60fps based on whether the browser is in an optimal state. */\nfunction tick () {\n    element.style.top = (startingTop += 1/60);\n}\n\nwindow.requestAnimationFrame(tick);\n```\n\nRAF可以提供对动画性能最大可能的提升，而为此你只需要对你的代码进行一个简单的修改。\n\n# css Transitions\n\nCSS transition的性能能够比 jQuery 动画好，transition将动画逻辑抛给浏览器自身来执行。它的优势体现在：\n\n1.通过优化 DOM 操作和内存消耗来避免卡顿\n\n2.利用RAF底层的原理\n\n3.强制硬件加速（使用GPU加速来提高动画效果）。\n\n然而实际上Javascript可以直接使用这些优化。GSAP 已经做这些优化有些年头了。Velocity.js ，一个新的动画引擎，不仅仅实现了相同的技术，而且走的更远些。\n\n面对现实，让 Javascript 动画可以与 CSS 动画性能竞争只是我们复兴计划的第一步。第二步是意识到事实上 Javascript 动画比 CSS 动画快！\n\n让我们以测试CSS动画的缺陷开始吧：\n\n1.Transition的强制使用GPU加速，致使动画卡顿不流畅和高负荷下的束缚。这种情况在移动设备上会加剧发生。（特别需要说明的是，卡顿是由于当数据在浏览器的主线程和其排序线程之间传输的时候发生的过载引起的。一些CSS属性，例如transforms和opacity，不会受到这种限制。）Adobe兄弟的博客谈论过这个话题。\n\n2. Transition在IE10不会起作用，这使得很多桌面场景残留的IE8、IE9中会产生兼容问题。\n\n3. 由于Transition不能原生地被javascript控制（仅仅是被javascript触发），浏览器不知道如何去优化操作Transition的javascript代码。\n\n相反的，基于javascript的动画库可以自己决定什么时候启用硬件加速，他们很自然的在IE各版本下正常工作，而且他们也非常适合批量动画优化。\n\n我的建议是可以在专门为移动端开发的页面上使用原生的css Transitions,并且你的动画只由简单的状态变化组成。在这样的情况下，transitions是一个允许你把动画的逻辑全部保留在css样式表里面，不会因为使用太多javascript库导致页面膨胀的 高性能内嵌的方法。但是，你如果正在设计复杂的UI动画或者正开发一款多状态UI的APP，记得用动画库，以便你的动画处于高性能状态，你的工作流程处于易处理状态。\n\nJavaScript动画\n\njavascript在使用的时候性能是可以占优势的。但javascript究竟可以快多少？开始--快到足以建立一个对比强烈的3D演示动画，就像你想的那样，通常用webGl才能完成的。快到足以建立一个复杂的多媒体动画，通常使用Flash或After Effects才能完成的。\n\n快到可以构建一个虚拟世界，通常使用canvas才能完成的。\n\n为了直接比较主流的动画库的表现，包括Transit（它使用了CSS的Transition），可以在这里先看看Velocity的官方文档：VelocityJS.org\n\n之前的问题还在：javascript如何达到高性能的？\n\n下面列出了一些优化，javascript的动画库可以胜任的表现：\n\n1. 同步DOM->调整堆栈之间的动画链来最小化布局抖动。\n\n2. 在链式调用中缓存属性值来最小化DOM查询的发生（这就是高性能动画的阿喀琉斯之踵）。\n\n3. 当更新基本上看不出来时，跳过样式更新。\n\n可以重温下我们之前讨论过的布局抖动，velocity.js利用这些最佳实践，来缓存动画结束值，使其被重用为随后的动画的起始值。以此来避免再次查询DOM元素的起始值。\n\n ```\n$element\n/* Slide the element down into view. */\n.velocity({ opacity: 1, top: \"50%\" })\n/* After a delay of 1000ms, slide the element out of view. */\n.velocity({ opacity: 0, top: \"-50%\" }, { delay: 1000 });\n ```\n\n 在上面的例子中，第二次velocity调用时已经知道，应该在opacity为1，top为50%时自动开始。\n\n浏览器可以自身执行类似这样的优化，但是这样做会很大程度上限制开发者手工写动画代码的方法。\n\n因此，基于同样的原因，Jquery不用RAF（见上文），浏览器从不实行 可能会打破规范或者偏离预期行为的优化。\n\n最后，让我们来比较一下两个javascript动画库（velocity和GSAP）。\n\n1. GSAP是一个快速，功能丰富的动画库平台。velocity是一个大大提高UI动画性能和工作刘的轻量级的工具。\n\n2. GSAP对于种类繁多的商业应用需要付费，velocity是完全开源免费的，它使用了十分自由的MITlicence。\n\n3. 在实际应用中，两者的性能表现相当。\n\n我的建议是你需要精确控制时间的时候使用GSAP（例如：remapping,暂停\\继续\\跳过），移动（例如贝塞尔曲线），或者复杂的动画组合\\队列。这些特性对于游戏开发及一些特殊应用十分重要，但在web应用中不太常见。\n\nGSAP有着富特性功能，但不意味着Velocity自身功能不丰富。相反，在压缩之后7KB的包里面，Velocity不仅仅实现了Jqueryanimate的所有功能，也打包了色彩动画，变换，循环，移动，类动画，滚动。\n","slug":"2018-04-17-css-vs-js-animation-performance","published":1,"updated":"2018-07-16T03:21:02.194Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjjnpdxpj0007sdmnxd7tg876","content":"<p>英文原文：<a href=\"https://davidwalsh.name/css-js-animation\" target=\"_blank\" rel=\"noopener\">https://davidwalsh.name/css-js-animation</a></p>\n<p>原作者Julian Shapiro是Velocity.js的作者，Velocity.js是一个高效易用的js动画库。在《Javascript网页动画设计》一书中对这个库有很多更具体的剖析.</p>\n<h1 id=\"JQuery\"><a href=\"#JQuery\" class=\"headerlink\" title=\"JQuery\"></a>JQuery</h1><p> Javascript 和 jQuery 两者不能错误的混为一谈。Javascript 动画很快，而 jQuery 动画却慢下来。为什么呢？因为尽管 jQuery 非常强大，但是它的设计目标并不是一个高效的动画引擎：</p>\n<a id=\"more\"></a>\n<ol>\n<li><p>JQuery不能避免layout thrashing，由于它不仅仅要服务于动画，也需要用于其他场景。</p>\n</li>\n<li><p>JQuery的内存消耗会频繁的触发垃圾回收机制，而垃圾回收会让动画暂时卡住。</p>\n</li>\n<li><p>JQuery使用了setInterval而不是requestAnimationFrame(RAF)，为了避免RAF在失去焦点的时候停止动画(译者注：JQuery3.0集成了RAF，不支持IE8及以下版本了)。</p>\n</li>\n</ol>\n<p>注意 layout thrashing 是导致动画在开始的时候卡顿的原因，垃圾回收是导致动画运行过程中的卡顿的原因，不使用 RAF 通常会导致动画帧率低。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var currentTop, currentLeft;</span><br><span class=\"line\"></span><br><span class=\"line\">/* With layout thrashing. */</span><br><span class=\"line\">currentTop = element.style.top; /* QUERY */</span><br><span class=\"line\">element.style.top = currentTop + 1; /* UPDATE */</span><br><span class=\"line\"></span><br><span class=\"line\">currentLeft = element.style.left; /* QUERY */</span><br><span class=\"line\">element.style.left = currentLeft + 1; /* UPDATE */</span><br><span class=\"line\"></span><br><span class=\"line\">/* Without layout thrashing. */</span><br><span class=\"line\">currentTop = element.style.top; /* QUERY */</span><br><span class=\"line\">currentLeft = element.style.left; /* QUERY */</span><br><span class=\"line\"></span><br><span class=\"line\">element.style.top = currentTop + 1; /* UPDATE */</span><br><span class=\"line\">element.style.left = currentLeft + 1; /* UPDATE */</span><br></pre></td></tr></table></figure>\n<p>在更新操作之后的访问操作会强制浏览器重新计算页面元素的样式（因为要将更新的样式应用上去才能获取正确的值）。这个在一般操作下没太大的性能损失，但是放在间隔仅仅16ms的动画中则会导致显著的性能开销。只需要稍微改动下操作的顺序就可以大大提高动画的性能。</p>\n<p>类似地，使用 RAF 也不会迫使你大量重构现在的代码。让我们来比较下使用 RAF 和使用 setInterval 的区别：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var startingTop = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">/* setInterval: Runs every 16ms to achieve 60fps (1000ms/60 ~= 16ms). */</span><br><span class=\"line\">setInterval(function() &#123;</span><br><span class=\"line\">    /* Since this ticks 60 times a second, we divide the top property&apos;s increment of 1 unit per 1 second by 60. */</span><br><span class=\"line\">    element.style.top = (startingTop += 1/60);</span><br><span class=\"line\">&#125;, 16);</span><br><span class=\"line\"></span><br><span class=\"line\">/* requestAnimationFrame: Attempts to run at 60fps based on whether the browser is in an optimal state. */</span><br><span class=\"line\">function tick () &#123;</span><br><span class=\"line\">    element.style.top = (startingTop += 1/60);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">window.requestAnimationFrame(tick);</span><br></pre></td></tr></table></figure>\n<p>RAF可以提供对动画性能最大可能的提升，而为此你只需要对你的代码进行一个简单的修改。</p>\n<h1 id=\"css-Transitions\"><a href=\"#css-Transitions\" class=\"headerlink\" title=\"css Transitions\"></a>css Transitions</h1><p>CSS transition的性能能够比 jQuery 动画好，transition将动画逻辑抛给浏览器自身来执行。它的优势体现在：</p>\n<p>1.通过优化 DOM 操作和内存消耗来避免卡顿</p>\n<p>2.利用RAF底层的原理</p>\n<p>3.强制硬件加速（使用GPU加速来提高动画效果）。</p>\n<p>然而实际上Javascript可以直接使用这些优化。GSAP 已经做这些优化有些年头了。Velocity.js ，一个新的动画引擎，不仅仅实现了相同的技术，而且走的更远些。</p>\n<p>面对现实，让 Javascript 动画可以与 CSS 动画性能竞争只是我们复兴计划的第一步。第二步是意识到事实上 Javascript 动画比 CSS 动画快！</p>\n<p>让我们以测试CSS动画的缺陷开始吧：</p>\n<p>1.Transition的强制使用GPU加速，致使动画卡顿不流畅和高负荷下的束缚。这种情况在移动设备上会加剧发生。（特别需要说明的是，卡顿是由于当数据在浏览器的主线程和其排序线程之间传输的时候发生的过载引起的。一些CSS属性，例如transforms和opacity，不会受到这种限制。）Adobe兄弟的博客谈论过这个话题。</p>\n<ol start=\"2\">\n<li><p>Transition在IE10不会起作用，这使得很多桌面场景残留的IE8、IE9中会产生兼容问题。</p>\n</li>\n<li><p>由于Transition不能原生地被javascript控制（仅仅是被javascript触发），浏览器不知道如何去优化操作Transition的javascript代码。</p>\n</li>\n</ol>\n<p>相反的，基于javascript的动画库可以自己决定什么时候启用硬件加速，他们很自然的在IE各版本下正常工作，而且他们也非常适合批量动画优化。</p>\n<p>我的建议是可以在专门为移动端开发的页面上使用原生的css Transitions,并且你的动画只由简单的状态变化组成。在这样的情况下，transitions是一个允许你把动画的逻辑全部保留在css样式表里面，不会因为使用太多javascript库导致页面膨胀的 高性能内嵌的方法。但是，你如果正在设计复杂的UI动画或者正开发一款多状态UI的APP，记得用动画库，以便你的动画处于高性能状态，你的工作流程处于易处理状态。</p>\n<p>JavaScript动画</p>\n<p>javascript在使用的时候性能是可以占优势的。但javascript究竟可以快多少？开始–快到足以建立一个对比强烈的3D演示动画，就像你想的那样，通常用webGl才能完成的。快到足以建立一个复杂的多媒体动画，通常使用Flash或After Effects才能完成的。</p>\n<p>快到可以构建一个虚拟世界，通常使用canvas才能完成的。</p>\n<p>为了直接比较主流的动画库的表现，包括Transit（它使用了CSS的Transition），可以在这里先看看Velocity的官方文档：VelocityJS.org</p>\n<p>之前的问题还在：javascript如何达到高性能的？</p>\n<p>下面列出了一些优化，javascript的动画库可以胜任的表现：</p>\n<ol>\n<li><p>同步DOM-&gt;调整堆栈之间的动画链来最小化布局抖动。</p>\n</li>\n<li><p>在链式调用中缓存属性值来最小化DOM查询的发生（这就是高性能动画的阿喀琉斯之踵）。</p>\n</li>\n<li><p>当更新基本上看不出来时，跳过样式更新。</p>\n</li>\n</ol>\n<p>可以重温下我们之前讨论过的布局抖动，velocity.js利用这些最佳实践，来缓存动画结束值，使其被重用为随后的动画的起始值。以此来避免再次查询DOM元素的起始值。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$element</span><br><span class=\"line\">/* Slide the element down into view. */</span><br><span class=\"line\">.velocity(&#123; opacity: 1, top: &quot;50%&quot; &#125;)</span><br><span class=\"line\">/* After a delay of 1000ms, slide the element out of view. */</span><br><span class=\"line\">.velocity(&#123; opacity: 0, top: &quot;-50%&quot; &#125;, &#123; delay: 1000 &#125;);</span><br></pre></td></tr></table></figure>\n<p> 在上面的例子中，第二次velocity调用时已经知道，应该在opacity为1，top为50%时自动开始。</p>\n<p>浏览器可以自身执行类似这样的优化，但是这样做会很大程度上限制开发者手工写动画代码的方法。</p>\n<p>因此，基于同样的原因，Jquery不用RAF（见上文），浏览器从不实行 可能会打破规范或者偏离预期行为的优化。</p>\n<p>最后，让我们来比较一下两个javascript动画库（velocity和GSAP）。</p>\n<ol>\n<li><p>GSAP是一个快速，功能丰富的动画库平台。velocity是一个大大提高UI动画性能和工作刘的轻量级的工具。</p>\n</li>\n<li><p>GSAP对于种类繁多的商业应用需要付费，velocity是完全开源免费的，它使用了十分自由的MITlicence。</p>\n</li>\n<li><p>在实际应用中，两者的性能表现相当。</p>\n</li>\n</ol>\n<p>我的建议是你需要精确控制时间的时候使用GSAP（例如：remapping,暂停\\继续\\跳过），移动（例如贝塞尔曲线），或者复杂的动画组合\\队列。这些特性对于游戏开发及一些特殊应用十分重要，但在web应用中不太常见。</p>\n<p>GSAP有着富特性功能，但不意味着Velocity自身功能不丰富。相反，在压缩之后7KB的包里面，Velocity不仅仅实现了Jqueryanimate的所有功能，也打包了色彩动画，变换，循环，移动，类动画，滚动。</p>\n","site":{"data":{}},"excerpt":"<p>英文原文：<a href=\"https://davidwalsh.name/css-js-animation\" target=\"_blank\" rel=\"noopener\">https://davidwalsh.name/css-js-animation</a></p>\n<p>原作者Julian Shapiro是Velocity.js的作者，Velocity.js是一个高效易用的js动画库。在《Javascript网页动画设计》一书中对这个库有很多更具体的剖析.</p>\n<h1 id=\"JQuery\"><a href=\"#JQuery\" class=\"headerlink\" title=\"JQuery\"></a>JQuery</h1><p> Javascript 和 jQuery 两者不能错误的混为一谈。Javascript 动画很快，而 jQuery 动画却慢下来。为什么呢？因为尽管 jQuery 非常强大，但是它的设计目标并不是一个高效的动画引擎：</p>","more":"<ol>\n<li><p>JQuery不能避免layout thrashing，由于它不仅仅要服务于动画，也需要用于其他场景。</p>\n</li>\n<li><p>JQuery的内存消耗会频繁的触发垃圾回收机制，而垃圾回收会让动画暂时卡住。</p>\n</li>\n<li><p>JQuery使用了setInterval而不是requestAnimationFrame(RAF)，为了避免RAF在失去焦点的时候停止动画(译者注：JQuery3.0集成了RAF，不支持IE8及以下版本了)。</p>\n</li>\n</ol>\n<p>注意 layout thrashing 是导致动画在开始的时候卡顿的原因，垃圾回收是导致动画运行过程中的卡顿的原因，不使用 RAF 通常会导致动画帧率低。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var currentTop, currentLeft;</span><br><span class=\"line\"></span><br><span class=\"line\">/* With layout thrashing. */</span><br><span class=\"line\">currentTop = element.style.top; /* QUERY */</span><br><span class=\"line\">element.style.top = currentTop + 1; /* UPDATE */</span><br><span class=\"line\"></span><br><span class=\"line\">currentLeft = element.style.left; /* QUERY */</span><br><span class=\"line\">element.style.left = currentLeft + 1; /* UPDATE */</span><br><span class=\"line\"></span><br><span class=\"line\">/* Without layout thrashing. */</span><br><span class=\"line\">currentTop = element.style.top; /* QUERY */</span><br><span class=\"line\">currentLeft = element.style.left; /* QUERY */</span><br><span class=\"line\"></span><br><span class=\"line\">element.style.top = currentTop + 1; /* UPDATE */</span><br><span class=\"line\">element.style.left = currentLeft + 1; /* UPDATE */</span><br></pre></td></tr></table></figure>\n<p>在更新操作之后的访问操作会强制浏览器重新计算页面元素的样式（因为要将更新的样式应用上去才能获取正确的值）。这个在一般操作下没太大的性能损失，但是放在间隔仅仅16ms的动画中则会导致显著的性能开销。只需要稍微改动下操作的顺序就可以大大提高动画的性能。</p>\n<p>类似地，使用 RAF 也不会迫使你大量重构现在的代码。让我们来比较下使用 RAF 和使用 setInterval 的区别：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var startingTop = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">/* setInterval: Runs every 16ms to achieve 60fps (1000ms/60 ~= 16ms). */</span><br><span class=\"line\">setInterval(function() &#123;</span><br><span class=\"line\">    /* Since this ticks 60 times a second, we divide the top property&apos;s increment of 1 unit per 1 second by 60. */</span><br><span class=\"line\">    element.style.top = (startingTop += 1/60);</span><br><span class=\"line\">&#125;, 16);</span><br><span class=\"line\"></span><br><span class=\"line\">/* requestAnimationFrame: Attempts to run at 60fps based on whether the browser is in an optimal state. */</span><br><span class=\"line\">function tick () &#123;</span><br><span class=\"line\">    element.style.top = (startingTop += 1/60);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">window.requestAnimationFrame(tick);</span><br></pre></td></tr></table></figure>\n<p>RAF可以提供对动画性能最大可能的提升，而为此你只需要对你的代码进行一个简单的修改。</p>\n<h1 id=\"css-Transitions\"><a href=\"#css-Transitions\" class=\"headerlink\" title=\"css Transitions\"></a>css Transitions</h1><p>CSS transition的性能能够比 jQuery 动画好，transition将动画逻辑抛给浏览器自身来执行。它的优势体现在：</p>\n<p>1.通过优化 DOM 操作和内存消耗来避免卡顿</p>\n<p>2.利用RAF底层的原理</p>\n<p>3.强制硬件加速（使用GPU加速来提高动画效果）。</p>\n<p>然而实际上Javascript可以直接使用这些优化。GSAP 已经做这些优化有些年头了。Velocity.js ，一个新的动画引擎，不仅仅实现了相同的技术，而且走的更远些。</p>\n<p>面对现实，让 Javascript 动画可以与 CSS 动画性能竞争只是我们复兴计划的第一步。第二步是意识到事实上 Javascript 动画比 CSS 动画快！</p>\n<p>让我们以测试CSS动画的缺陷开始吧：</p>\n<p>1.Transition的强制使用GPU加速，致使动画卡顿不流畅和高负荷下的束缚。这种情况在移动设备上会加剧发生。（特别需要说明的是，卡顿是由于当数据在浏览器的主线程和其排序线程之间传输的时候发生的过载引起的。一些CSS属性，例如transforms和opacity，不会受到这种限制。）Adobe兄弟的博客谈论过这个话题。</p>\n<ol start=\"2\">\n<li><p>Transition在IE10不会起作用，这使得很多桌面场景残留的IE8、IE9中会产生兼容问题。</p>\n</li>\n<li><p>由于Transition不能原生地被javascript控制（仅仅是被javascript触发），浏览器不知道如何去优化操作Transition的javascript代码。</p>\n</li>\n</ol>\n<p>相反的，基于javascript的动画库可以自己决定什么时候启用硬件加速，他们很自然的在IE各版本下正常工作，而且他们也非常适合批量动画优化。</p>\n<p>我的建议是可以在专门为移动端开发的页面上使用原生的css Transitions,并且你的动画只由简单的状态变化组成。在这样的情况下，transitions是一个允许你把动画的逻辑全部保留在css样式表里面，不会因为使用太多javascript库导致页面膨胀的 高性能内嵌的方法。但是，你如果正在设计复杂的UI动画或者正开发一款多状态UI的APP，记得用动画库，以便你的动画处于高性能状态，你的工作流程处于易处理状态。</p>\n<p>JavaScript动画</p>\n<p>javascript在使用的时候性能是可以占优势的。但javascript究竟可以快多少？开始–快到足以建立一个对比强烈的3D演示动画，就像你想的那样，通常用webGl才能完成的。快到足以建立一个复杂的多媒体动画，通常使用Flash或After Effects才能完成的。</p>\n<p>快到可以构建一个虚拟世界，通常使用canvas才能完成的。</p>\n<p>为了直接比较主流的动画库的表现，包括Transit（它使用了CSS的Transition），可以在这里先看看Velocity的官方文档：VelocityJS.org</p>\n<p>之前的问题还在：javascript如何达到高性能的？</p>\n<p>下面列出了一些优化，javascript的动画库可以胜任的表现：</p>\n<ol>\n<li><p>同步DOM-&gt;调整堆栈之间的动画链来最小化布局抖动。</p>\n</li>\n<li><p>在链式调用中缓存属性值来最小化DOM查询的发生（这就是高性能动画的阿喀琉斯之踵）。</p>\n</li>\n<li><p>当更新基本上看不出来时，跳过样式更新。</p>\n</li>\n</ol>\n<p>可以重温下我们之前讨论过的布局抖动，velocity.js利用这些最佳实践，来缓存动画结束值，使其被重用为随后的动画的起始值。以此来避免再次查询DOM元素的起始值。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$element</span><br><span class=\"line\">/* Slide the element down into view. */</span><br><span class=\"line\">.velocity(&#123; opacity: 1, top: &quot;50%&quot; &#125;)</span><br><span class=\"line\">/* After a delay of 1000ms, slide the element out of view. */</span><br><span class=\"line\">.velocity(&#123; opacity: 0, top: &quot;-50%&quot; &#125;, &#123; delay: 1000 &#125;);</span><br></pre></td></tr></table></figure>\n<p> 在上面的例子中，第二次velocity调用时已经知道，应该在opacity为1，top为50%时自动开始。</p>\n<p>浏览器可以自身执行类似这样的优化，但是这样做会很大程度上限制开发者手工写动画代码的方法。</p>\n<p>因此，基于同样的原因，Jquery不用RAF（见上文），浏览器从不实行 可能会打破规范或者偏离预期行为的优化。</p>\n<p>最后，让我们来比较一下两个javascript动画库（velocity和GSAP）。</p>\n<ol>\n<li><p>GSAP是一个快速，功能丰富的动画库平台。velocity是一个大大提高UI动画性能和工作刘的轻量级的工具。</p>\n</li>\n<li><p>GSAP对于种类繁多的商业应用需要付费，velocity是完全开源免费的，它使用了十分自由的MITlicence。</p>\n</li>\n<li><p>在实际应用中，两者的性能表现相当。</p>\n</li>\n</ol>\n<p>我的建议是你需要精确控制时间的时候使用GSAP（例如：remapping,暂停\\继续\\跳过），移动（例如贝塞尔曲线），或者复杂的动画组合\\队列。这些特性对于游戏开发及一些特殊应用十分重要，但在web应用中不太常见。</p>\n<p>GSAP有着富特性功能，但不意味着Velocity自身功能不丰富。相反，在压缩之后7KB的包里面，Velocity不仅仅实现了Jqueryanimate的所有功能，也打包了色彩动画，变换，循环，移动，类动画，滚动。</p>"},{"title":"React从子组件到父组件的关联渲染","date":"2018-04-27T05:09:50.000Z","_content":"\n开发过程中会遇到这样的场景：组件A是组件B的父组件，当用户对组件B进行操作时，需要组件A进行响应的状态或者展示效果改变。一般情况下，我们会用React的action达到所需要的效果，\n<!-- more -->\n除此还可以用回调函数实现，在组件复用场景下，回调可能是更为轻便的实现。如下代码所示：\n\n```jsx\n// Child Component\nconst optFuc = () => { this.props.optFuc; }\n\n// Parent Component\n<Child onOperation={optFuc} />\n```\n","source":"_posts/2018-04-27_react_pile_from_parent_to_child_component.md","raw":"---\ntitle: React从子组件到父组件的关联渲染\ndate: 2018-4-27 13:09:50\ntags: [React]\n---\n\n开发过程中会遇到这样的场景：组件A是组件B的父组件，当用户对组件B进行操作时，需要组件A进行响应的状态或者展示效果改变。一般情况下，我们会用React的action达到所需要的效果，\n<!-- more -->\n除此还可以用回调函数实现，在组件复用场景下，回调可能是更为轻便的实现。如下代码所示：\n\n```jsx\n// Child Component\nconst optFuc = () => { this.props.optFuc; }\n\n// Parent Component\n<Child onOperation={optFuc} />\n```\n","slug":"2018-04-27_react_pile_from_parent_to_child_component","published":1,"updated":"2018-07-16T03:21:02.195Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjjnpdxpk0008sdmn8ywwmc3s","content":"<p>开发过程中会遇到这样的场景：组件A是组件B的父组件，当用户对组件B进行操作时，需要组件A进行响应的状态或者展示效果改变。一般情况下，我们会用React的action达到所需要的效果，<br><a id=\"more\"></a><br>除此还可以用回调函数实现，在组件复用场景下，回调可能是更为轻便的实现。如下代码所示：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Child Component</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> optFuc = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; <span class=\"keyword\">this</span>.props.optFuc; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Parent Component</span></span><br><span class=\"line\">&lt;Child onOperation=&#123;optFuc&#125; /&gt;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>开发过程中会遇到这样的场景：组件A是组件B的父组件，当用户对组件B进行操作时，需要组件A进行响应的状态或者展示效果改变。一般情况下，我们会用React的action达到所需要的效果，<br>","more":"<br>除此还可以用回调函数实现，在组件复用场景下，回调可能是更为轻便的实现。如下代码所示：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Child Component</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> optFuc = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; <span class=\"keyword\">this</span>.props.optFuc; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Parent Component</span></span><br><span class=\"line\">&lt;Child onOperation=&#123;optFuc&#125; /&gt;</span><br></pre></td></tr></table></figure>"},{"title":"React的ref属性","date":"2018-05-01T14:15:52.000Z","_content":"\n# 前言\n **react典型的数据流**：通过传递一个新的props值来使子组件重新re-render\n\n**ref方式**是除react典型数据流之外，实现修改子组件的另一种方式，这种方式适合与==第三方DOM库的整合，或者某个DOM元素Focus==\n\n<!-- more -->\n\n# ref简介\n\nReact提供ref属性，表示为对组件真正实例的引用，就是ReactDOM.render()返回的组件实例。---- ReactDOM.render()渲染组件时返回的是组件实例；而渲染dom元素时，返回是具体的DOM节点。可以使用以下代码观察输出：\n\n```JSX\nconst domCom = <button type=\"button\">button<[表情]tton>;\nconst refDom = ReactDOM.render(domCom，container);\n    //ConfirmPass的组件内容省略\nconst refCom = ReactDOM.render(<ConfirmPass/>,container);\nconsole.log(refDom);\nconsole.log(refCom);\n```\n\nref可以挂到任何组件上，可以挂到组件上也可以是DOM元素上：挂到组件（特指有状态组件）上的ref表示对组件实例的引用；挂在DOM元素上时表示具体的DOM元素节点。\n\n==**注意：无状态组件不会被实例化，因此无法使用ref获取组件实例，其值为null。**==\n\n对于无状态组件，想访问的无非是其中包含的组件或者DOM元素，可以通过一个变量来保存想要的组件或者DOM元素组件的实例引用。例如下面代码：\n\n```\nfunction TestComp(props){\n    let reDom;\n    return (\n        <div>\n            <div ref={(node) => refDom = node}>\n                ...\n            </div>\n        </div>\n    );\n}\n```\n\n这样，可以通过变量refDom来访问无状态组件中的指定DOM元素了。\n\n# ref的使用\n\n#### ref可以设置回调函数\n\n官方推荐将ref属性设置为一个回调函数，这个函数执行的时机为：\n\n- 组件被挂载后，回调函数被立即执行，回调函数的参数为该组件的具体实例。\n- 组件被卸载或者原有的ref属性本身发生变化时，回调函数也会被立即执行，此时回调函数参数为null，确保内存不会泄露\n\n可运行下方代码加深了解：\n```JSX\nRegisterStepTwo = React.createClass({\n    getInitialState(){\n      return {visible: true};\n    },\n  changeVisible(){\n    this.setState({visible: !this.state.visible});\n  },\n  refCb(instance){\n    console.log(instance);\n  },\n  render(){\n    return(\n      <div>\n        <button type=\"button\" onClick={this.changeVisible}>{this.state.visible ? '卸载' : '挂载'}ConfirmPass\n        <[表情]tton>\n        {\n          this.state.visible ?\n            <ConfirmPass ref={this.refCb} onChange={this.handleChange}/>: null\n         }\n       </div>\n     )\n  }\n});\n```\n\n#### ref可以设置字符串\n\n这种方式基本不推荐使用，或者在未来的React版本中不会再支持该方式。\n\n```JSX\n<input ref=\"input\" />\n```\n\n在其他地方，如事件回调中通过this.refs.input 可以访问到该组件实例：\n\n```\nlet inputEl = this.refs.input;\n// TODO - 通过inputEl完成后续逻辑，如Focus、值获取等等\n```\n\n<hr />\n\n不管ref设置的值是回调函数还是字符串，都可以通过ReactDOM.findDOMNode(ref)来获取组件挂载后真正的DOM节点。\n\n但是对于HTML元素使用ref的情况，ref本身引用的就是该元素的实际DOM节点，无需使用ReactDOM.findDOMNode(ref)来获取，该方法常用于React组件上的ref。\n\n# 总结\n\nref提供了一种对于react标准的数据流不太适用的情况下组件间交互的方式，例如管理dom元素focus、text selection以及与第三方的dom库整合等等。 但是在大多数情况下应该使用react响应数据流那种方式，不要过度使用ref。\n\n另外，在使用ref时，不用担心会导致内存泄露的问题，react会自动帮你管理好，在组件卸载时ref值也会被销毁。\n\n最后：不要在组件的render方法中访问ref引用，render方法只是返回一个虚拟DOM，这是组件不一定挂载到DOM中，或者render返回的虚拟DOM不一定会更新到DOM中。\n\n\n# 参考\n\n- [React之ref详细用法](https://segmentfault.com/a/1190000008665915)\n- [React创建组件的三种方式及其区别](http://www.cnblogs.com/wonyun/p/5930333.html)\n- [React从入门到精通系列之(14)refs和DOM元素](https://segmentfault.com/a/1190000007815434)\n- [对组件的引用(refs)](http://bbs.reactnative.cn/topic/608/%E5%AF%B9%E7%BB%84%E4%BB%B6%E7%9A%84%E5%BC%95%E7%94%A8-refs/2)\n","source":"_posts/2018-05-02_ref_of_react.md","raw":"---\ntitle: React的ref属性\ndate: 2018-05-01 22:15:52\ntags: [React, ref]\n---\n\n# 前言\n **react典型的数据流**：通过传递一个新的props值来使子组件重新re-render\n\n**ref方式**是除react典型数据流之外，实现修改子组件的另一种方式，这种方式适合与==第三方DOM库的整合，或者某个DOM元素Focus==\n\n<!-- more -->\n\n# ref简介\n\nReact提供ref属性，表示为对组件真正实例的引用，就是ReactDOM.render()返回的组件实例。---- ReactDOM.render()渲染组件时返回的是组件实例；而渲染dom元素时，返回是具体的DOM节点。可以使用以下代码观察输出：\n\n```JSX\nconst domCom = <button type=\"button\">button<[表情]tton>;\nconst refDom = ReactDOM.render(domCom，container);\n    //ConfirmPass的组件内容省略\nconst refCom = ReactDOM.render(<ConfirmPass/>,container);\nconsole.log(refDom);\nconsole.log(refCom);\n```\n\nref可以挂到任何组件上，可以挂到组件上也可以是DOM元素上：挂到组件（特指有状态组件）上的ref表示对组件实例的引用；挂在DOM元素上时表示具体的DOM元素节点。\n\n==**注意：无状态组件不会被实例化，因此无法使用ref获取组件实例，其值为null。**==\n\n对于无状态组件，想访问的无非是其中包含的组件或者DOM元素，可以通过一个变量来保存想要的组件或者DOM元素组件的实例引用。例如下面代码：\n\n```\nfunction TestComp(props){\n    let reDom;\n    return (\n        <div>\n            <div ref={(node) => refDom = node}>\n                ...\n            </div>\n        </div>\n    );\n}\n```\n\n这样，可以通过变量refDom来访问无状态组件中的指定DOM元素了。\n\n# ref的使用\n\n#### ref可以设置回调函数\n\n官方推荐将ref属性设置为一个回调函数，这个函数执行的时机为：\n\n- 组件被挂载后，回调函数被立即执行，回调函数的参数为该组件的具体实例。\n- 组件被卸载或者原有的ref属性本身发生变化时，回调函数也会被立即执行，此时回调函数参数为null，确保内存不会泄露\n\n可运行下方代码加深了解：\n```JSX\nRegisterStepTwo = React.createClass({\n    getInitialState(){\n      return {visible: true};\n    },\n  changeVisible(){\n    this.setState({visible: !this.state.visible});\n  },\n  refCb(instance){\n    console.log(instance);\n  },\n  render(){\n    return(\n      <div>\n        <button type=\"button\" onClick={this.changeVisible}>{this.state.visible ? '卸载' : '挂载'}ConfirmPass\n        <[表情]tton>\n        {\n          this.state.visible ?\n            <ConfirmPass ref={this.refCb} onChange={this.handleChange}/>: null\n         }\n       </div>\n     )\n  }\n});\n```\n\n#### ref可以设置字符串\n\n这种方式基本不推荐使用，或者在未来的React版本中不会再支持该方式。\n\n```JSX\n<input ref=\"input\" />\n```\n\n在其他地方，如事件回调中通过this.refs.input 可以访问到该组件实例：\n\n```\nlet inputEl = this.refs.input;\n// TODO - 通过inputEl完成后续逻辑，如Focus、值获取等等\n```\n\n<hr />\n\n不管ref设置的值是回调函数还是字符串，都可以通过ReactDOM.findDOMNode(ref)来获取组件挂载后真正的DOM节点。\n\n但是对于HTML元素使用ref的情况，ref本身引用的就是该元素的实际DOM节点，无需使用ReactDOM.findDOMNode(ref)来获取，该方法常用于React组件上的ref。\n\n# 总结\n\nref提供了一种对于react标准的数据流不太适用的情况下组件间交互的方式，例如管理dom元素focus、text selection以及与第三方的dom库整合等等。 但是在大多数情况下应该使用react响应数据流那种方式，不要过度使用ref。\n\n另外，在使用ref时，不用担心会导致内存泄露的问题，react会自动帮你管理好，在组件卸载时ref值也会被销毁。\n\n最后：不要在组件的render方法中访问ref引用，render方法只是返回一个虚拟DOM，这是组件不一定挂载到DOM中，或者render返回的虚拟DOM不一定会更新到DOM中。\n\n\n# 参考\n\n- [React之ref详细用法](https://segmentfault.com/a/1190000008665915)\n- [React创建组件的三种方式及其区别](http://www.cnblogs.com/wonyun/p/5930333.html)\n- [React从入门到精通系列之(14)refs和DOM元素](https://segmentfault.com/a/1190000007815434)\n- [对组件的引用(refs)](http://bbs.reactnative.cn/topic/608/%E5%AF%B9%E7%BB%84%E4%BB%B6%E7%9A%84%E5%BC%95%E7%94%A8-refs/2)\n","slug":"2018-05-02_ref_of_react","published":1,"updated":"2018-07-16T03:21:02.195Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjjnpdxpm000asdmno1nilplm","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p> <strong>react典型的数据流</strong>：通过传递一个新的props值来使子组件重新re-render</p>\n<p><strong>ref方式</strong>是除react典型数据流之外，实现修改子组件的另一种方式，这种方式适合与==第三方DOM库的整合，或者某个DOM元素Focus==</p>\n<a id=\"more\"></a>\n<h1 id=\"ref简介\"><a href=\"#ref简介\" class=\"headerlink\" title=\"ref简介\"></a>ref简介</h1><p>React提供ref属性，表示为对组件真正实例的引用，就是ReactDOM.render()返回的组件实例。—- ReactDOM.render()渲染组件时返回的是组件实例；而渲染dom元素时，返回是具体的DOM节点。可以使用以下代码观察输出：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> domCom = &lt;button type=\"button\"&gt;button&lt;[表情]tton&gt;;</span><br><span class=\"line\">const refDom = ReactDOM.render(domCom，container);</span><br><span class=\"line\">    //ConfirmPass的组件内容省略</span><br><span class=\"line\">const refCom = ReactDOM.render(&lt;ConfirmPass/&gt;,container);</span><br><span class=\"line\">console.log(refDom);</span><br><span class=\"line\">console.log(refCom);</span><br></pre></td></tr></table></figure>\n<p>ref可以挂到任何组件上，可以挂到组件上也可以是DOM元素上：挂到组件（特指有状态组件）上的ref表示对组件实例的引用；挂在DOM元素上时表示具体的DOM元素节点。</p>\n<p>==<strong>注意：无状态组件不会被实例化，因此无法使用ref获取组件实例，其值为null。</strong>==</p>\n<p>对于无状态组件，想访问的无非是其中包含的组件或者DOM元素，可以通过一个变量来保存想要的组件或者DOM元素组件的实例引用。例如下面代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function TestComp(props)&#123;</span><br><span class=\"line\">    let reDom;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;div ref=&#123;(node) =&gt; refDom = node&#125;&gt;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">            &lt;/div&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，可以通过变量refDom来访问无状态组件中的指定DOM元素了。</p>\n<h1 id=\"ref的使用\"><a href=\"#ref的使用\" class=\"headerlink\" title=\"ref的使用\"></a>ref的使用</h1><h4 id=\"ref可以设置回调函数\"><a href=\"#ref可以设置回调函数\" class=\"headerlink\" title=\"ref可以设置回调函数\"></a>ref可以设置回调函数</h4><p>官方推荐将ref属性设置为一个回调函数，这个函数执行的时机为：</p>\n<ul>\n<li>组件被挂载后，回调函数被立即执行，回调函数的参数为该组件的具体实例。</li>\n<li>组件被卸载或者原有的ref属性本身发生变化时，回调函数也会被立即执行，此时回调函数参数为null，确保内存不会泄露</li>\n</ul>\n<p>可运行下方代码加深了解：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RegisterStepTwo = React.createClass(&#123;</span><br><span class=\"line\">    getInitialState()&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123;<span class=\"attr\">visible</span>: <span class=\"literal\">true</span>&#125;;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  changeVisible()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">visible</span>: !<span class=\"keyword\">this</span>.state.visible&#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  refCb(instance)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(instance);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>(</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;button type=<span class=\"string\">\"button\"</span> onClick=&#123;<span class=\"keyword\">this</span>.changeVisible&#125;&gt;&#123;<span class=\"keyword\">this</span>.state.visible ? <span class=\"string\">'卸载'</span> : <span class=\"string\">'挂载'</span>&#125;ConfirmPass</span><br><span class=\"line\">        &lt;[表情]tton&gt;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.state.visible ?</span><br><span class=\"line\">            &lt;ConfirmPass ref=&#123;<span class=\"keyword\">this</span>.refCb&#125; onChange=&#123;<span class=\"keyword\">this</span>.handleChange&#125;/&gt;: <span class=\"literal\">null</span></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">       &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">     )</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"ref可以设置字符串\"><a href=\"#ref可以设置字符串\" class=\"headerlink\" title=\"ref可以设置字符串\"></a>ref可以设置字符串</h4><p>这种方式基本不推荐使用，或者在未来的React版本中不会再支持该方式。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input ref=<span class=\"string\">\"input\"</span> /&gt;</span><br></pre></td></tr></table></figure>\n<p>在其他地方，如事件回调中通过this.refs.input 可以访问到该组件实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let inputEl = this.refs.input;</span><br><span class=\"line\">// TODO - 通过inputEl完成后续逻辑，如Focus、值获取等等</span><br></pre></td></tr></table></figure>\n<hr>\n\n<p>不管ref设置的值是回调函数还是字符串，都可以通过ReactDOM.findDOMNode(ref)来获取组件挂载后真正的DOM节点。</p>\n<p>但是对于HTML元素使用ref的情况，ref本身引用的就是该元素的实际DOM节点，无需使用ReactDOM.findDOMNode(ref)来获取，该方法常用于React组件上的ref。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>ref提供了一种对于react标准的数据流不太适用的情况下组件间交互的方式，例如管理dom元素focus、text selection以及与第三方的dom库整合等等。 但是在大多数情况下应该使用react响应数据流那种方式，不要过度使用ref。</p>\n<p>另外，在使用ref时，不用担心会导致内存泄露的问题，react会自动帮你管理好，在组件卸载时ref值也会被销毁。</p>\n<p>最后：不要在组件的render方法中访问ref引用，render方法只是返回一个虚拟DOM，这是组件不一定挂载到DOM中，或者render返回的虚拟DOM不一定会更新到DOM中。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ul>\n<li><a href=\"https://segmentfault.com/a/1190000008665915\" target=\"_blank\" rel=\"noopener\">React之ref详细用法</a></li>\n<li><a href=\"http://www.cnblogs.com/wonyun/p/5930333.html\" target=\"_blank\" rel=\"noopener\">React创建组件的三种方式及其区别</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000007815434\" target=\"_blank\" rel=\"noopener\">React从入门到精通系列之(14)refs和DOM元素</a></li>\n<li><a href=\"http://bbs.reactnative.cn/topic/608/%E5%AF%B9%E7%BB%84%E4%BB%B6%E7%9A%84%E5%BC%95%E7%94%A8-refs/2\" target=\"_blank\" rel=\"noopener\">对组件的引用(refs)</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p> <strong>react典型的数据流</strong>：通过传递一个新的props值来使子组件重新re-render</p>\n<p><strong>ref方式</strong>是除react典型数据流之外，实现修改子组件的另一种方式，这种方式适合与==第三方DOM库的整合，或者某个DOM元素Focus==</p>","more":"<h1 id=\"ref简介\"><a href=\"#ref简介\" class=\"headerlink\" title=\"ref简介\"></a>ref简介</h1><p>React提供ref属性，表示为对组件真正实例的引用，就是ReactDOM.render()返回的组件实例。—- ReactDOM.render()渲染组件时返回的是组件实例；而渲染dom元素时，返回是具体的DOM节点。可以使用以下代码观察输出：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> domCom = &lt;button type=\"button\"&gt;button&lt;[表情]tton&gt;;</span><br><span class=\"line\">const refDom = ReactDOM.render(domCom，container);</span><br><span class=\"line\">    //ConfirmPass的组件内容省略</span><br><span class=\"line\">const refCom = ReactDOM.render(&lt;ConfirmPass/&gt;,container);</span><br><span class=\"line\">console.log(refDom);</span><br><span class=\"line\">console.log(refCom);</span><br></pre></td></tr></table></figure>\n<p>ref可以挂到任何组件上，可以挂到组件上也可以是DOM元素上：挂到组件（特指有状态组件）上的ref表示对组件实例的引用；挂在DOM元素上时表示具体的DOM元素节点。</p>\n<p>==<strong>注意：无状态组件不会被实例化，因此无法使用ref获取组件实例，其值为null。</strong>==</p>\n<p>对于无状态组件，想访问的无非是其中包含的组件或者DOM元素，可以通过一个变量来保存想要的组件或者DOM元素组件的实例引用。例如下面代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function TestComp(props)&#123;</span><br><span class=\"line\">    let reDom;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;div ref=&#123;(node) =&gt; refDom = node&#125;&gt;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">            &lt;/div&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，可以通过变量refDom来访问无状态组件中的指定DOM元素了。</p>\n<h1 id=\"ref的使用\"><a href=\"#ref的使用\" class=\"headerlink\" title=\"ref的使用\"></a>ref的使用</h1><h4 id=\"ref可以设置回调函数\"><a href=\"#ref可以设置回调函数\" class=\"headerlink\" title=\"ref可以设置回调函数\"></a>ref可以设置回调函数</h4><p>官方推荐将ref属性设置为一个回调函数，这个函数执行的时机为：</p>\n<ul>\n<li>组件被挂载后，回调函数被立即执行，回调函数的参数为该组件的具体实例。</li>\n<li>组件被卸载或者原有的ref属性本身发生变化时，回调函数也会被立即执行，此时回调函数参数为null，确保内存不会泄露</li>\n</ul>\n<p>可运行下方代码加深了解：<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RegisterStepTwo = React.createClass(&#123;</span><br><span class=\"line\">    getInitialState()&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123;<span class=\"attr\">visible</span>: <span class=\"literal\">true</span>&#125;;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  changeVisible()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">visible</span>: !<span class=\"keyword\">this</span>.state.visible&#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  refCb(instance)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(instance);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>(</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;button type=<span class=\"string\">\"button\"</span> onClick=&#123;<span class=\"keyword\">this</span>.changeVisible&#125;&gt;&#123;<span class=\"keyword\">this</span>.state.visible ? <span class=\"string\">'卸载'</span> : <span class=\"string\">'挂载'</span>&#125;ConfirmPass</span><br><span class=\"line\">        &lt;[表情]tton&gt;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.state.visible ?</span><br><span class=\"line\">            &lt;ConfirmPass ref=&#123;<span class=\"keyword\">this</span>.refCb&#125; onChange=&#123;<span class=\"keyword\">this</span>.handleChange&#125;/&gt;: <span class=\"literal\">null</span></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">       &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">     )</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"ref可以设置字符串\"><a href=\"#ref可以设置字符串\" class=\"headerlink\" title=\"ref可以设置字符串\"></a>ref可以设置字符串</h4><p>这种方式基本不推荐使用，或者在未来的React版本中不会再支持该方式。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input ref=<span class=\"string\">\"input\"</span> /&gt;</span><br></pre></td></tr></table></figure>\n<p>在其他地方，如事件回调中通过this.refs.input 可以访问到该组件实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let inputEl = this.refs.input;</span><br><span class=\"line\">// TODO - 通过inputEl完成后续逻辑，如Focus、值获取等等</span><br></pre></td></tr></table></figure>\n<hr>\n\n<p>不管ref设置的值是回调函数还是字符串，都可以通过ReactDOM.findDOMNode(ref)来获取组件挂载后真正的DOM节点。</p>\n<p>但是对于HTML元素使用ref的情况，ref本身引用的就是该元素的实际DOM节点，无需使用ReactDOM.findDOMNode(ref)来获取，该方法常用于React组件上的ref。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>ref提供了一种对于react标准的数据流不太适用的情况下组件间交互的方式，例如管理dom元素focus、text selection以及与第三方的dom库整合等等。 但是在大多数情况下应该使用react响应数据流那种方式，不要过度使用ref。</p>\n<p>另外，在使用ref时，不用担心会导致内存泄露的问题，react会自动帮你管理好，在组件卸载时ref值也会被销毁。</p>\n<p>最后：不要在组件的render方法中访问ref引用，render方法只是返回一个虚拟DOM，这是组件不一定挂载到DOM中，或者render返回的虚拟DOM不一定会更新到DOM中。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ul>\n<li><a href=\"https://segmentfault.com/a/1190000008665915\" target=\"_blank\" rel=\"noopener\">React之ref详细用法</a></li>\n<li><a href=\"http://www.cnblogs.com/wonyun/p/5930333.html\" target=\"_blank\" rel=\"noopener\">React创建组件的三种方式及其区别</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000007815434\" target=\"_blank\" rel=\"noopener\">React从入门到精通系列之(14)refs和DOM元素</a></li>\n<li><a href=\"http://bbs.reactnative.cn/topic/608/%E5%AF%B9%E7%BB%84%E4%BB%B6%E7%9A%84%E5%BC%95%E7%94%A8-refs/2\" target=\"_blank\" rel=\"noopener\">对组件的引用(refs)</a></li>\n</ul>"},{"title":"Hello World","date":"2017-04-22T14:15:34.000Z","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!-- more -->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2017-4-22 22:15:34\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!-- more -->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"updated":"2018-07-16T03:21:02.195Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjjnpdxpo000csdmn5ffnf6bc","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<a id=\"more\"></a>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>","more":"<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>"},{"title":"渐进增强与优雅降级","date":"2018-04-14T14:15:52.000Z","_content":"\n### 渐进增强与优雅降级\n\n##### 渐进增强（progressive enhancement）\n\n针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。（从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能，向页面添加无害于基础浏览器的额外样式和功能。当浏览器支持时，它们会自动地呈现出来并发挥作用。）\n\n<!-- more -->\n\n##### 优雅降级（graceful degradation）\n\n一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。（Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了，为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效。）\n\n其实渐进增强和优雅降级并非什么新概念，只是旧的概念换了一个新的说法。在传统软件开发中，经常会提到向上兼容和向下兼容的概念。渐进增强相当于向上兼容，而优雅降级相当于向下兼容。向下兼容指的是高版本支持低版本的或者说后期开发的版本支持和兼容早期开发的版本，向上兼容的很少。大多数软件都是向下兼容的，比如说Office2010能打开Office2007，Office2006，Office2005，Office2003等建的word文件，但是用Office2003就不能打开用Office2007，Office2010等建的word文件！\n\n##### 二者的区别\n\n优雅降级和渐进增强只是看待同种事物的两种观点。优雅降级和渐进增强都关注于同一网站在不同设备里不同浏览器下的表现程度。关键的区别则在于它们各自关注于何处，以及这种关注如何影响工作的流程。\n\n优雅降级观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。你可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。\n\n渐进增强观点则认为应关注于内容本身。请注意其中的差别：我甚至连“浏览器”三个字都没提。内容是我们建立网站的诱因。有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得渐进增强成为一种更为合理的设计范例。这也是它立即被 Yahoo! 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在。\n\n##### 举个栗子\n\n```css\n.transition { /*优雅降级写法*/\n  -webkit-transition: all .5s;\n     -moz-transition: all .5s;\n       -o-transition: all .5s;\n          transition: all .5s;\n}\n.transition { /*渐进增强写法*/\n          transition: all .5s;\n       -o-transition: all .5s;\n     -moz-transition: all .5s;\n  -webkit-transition: all .5s;\n}\n```\n","source":"_posts/2015-05-14-渐进增强与优雅降级.md","raw":"---\ntitle: 渐进增强与优雅降级\ndate: 2018-04-14 22:15:52\ntags: [Css]\n---\n\n### 渐进增强与优雅降级\n\n##### 渐进增强（progressive enhancement）\n\n针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。（从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能，向页面添加无害于基础浏览器的额外样式和功能。当浏览器支持时，它们会自动地呈现出来并发挥作用。）\n\n<!-- more -->\n\n##### 优雅降级（graceful degradation）\n\n一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。（Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了，为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效。）\n\n其实渐进增强和优雅降级并非什么新概念，只是旧的概念换了一个新的说法。在传统软件开发中，经常会提到向上兼容和向下兼容的概念。渐进增强相当于向上兼容，而优雅降级相当于向下兼容。向下兼容指的是高版本支持低版本的或者说后期开发的版本支持和兼容早期开发的版本，向上兼容的很少。大多数软件都是向下兼容的，比如说Office2010能打开Office2007，Office2006，Office2005，Office2003等建的word文件，但是用Office2003就不能打开用Office2007，Office2010等建的word文件！\n\n##### 二者的区别\n\n优雅降级和渐进增强只是看待同种事物的两种观点。优雅降级和渐进增强都关注于同一网站在不同设备里不同浏览器下的表现程度。关键的区别则在于它们各自关注于何处，以及这种关注如何影响工作的流程。\n\n优雅降级观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。你可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。\n\n渐进增强观点则认为应关注于内容本身。请注意其中的差别：我甚至连“浏览器”三个字都没提。内容是我们建立网站的诱因。有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得渐进增强成为一种更为合理的设计范例。这也是它立即被 Yahoo! 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在。\n\n##### 举个栗子\n\n```css\n.transition { /*优雅降级写法*/\n  -webkit-transition: all .5s;\n     -moz-transition: all .5s;\n       -o-transition: all .5s;\n          transition: all .5s;\n}\n.transition { /*渐进增强写法*/\n          transition: all .5s;\n       -o-transition: all .5s;\n     -moz-transition: all .5s;\n  -webkit-transition: all .5s;\n}\n```\n","slug":"2015-05-14-渐进增强与优雅降级","published":1,"updated":"2018-07-16T03:25:23.621Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjjnphwrd0000szmnw9kbqz67","content":"<h3 id=\"渐进增强与优雅降级\"><a href=\"#渐进增强与优雅降级\" class=\"headerlink\" title=\"渐进增强与优雅降级\"></a>渐进增强与优雅降级</h3><h5 id=\"渐进增强（progressive-enhancement）\"><a href=\"#渐进增强（progressive-enhancement）\" class=\"headerlink\" title=\"渐进增强（progressive enhancement）\"></a>渐进增强（progressive enhancement）</h5><p>针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。（从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能，向页面添加无害于基础浏览器的额外样式和功能。当浏览器支持时，它们会自动地呈现出来并发挥作用。）</p>\n<a id=\"more\"></a>\n<h5 id=\"优雅降级（graceful-degradation）\"><a href=\"#优雅降级（graceful-degradation）\" class=\"headerlink\" title=\"优雅降级（graceful degradation）\"></a>优雅降级（graceful degradation）</h5><p>一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。（Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了，为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效。）</p>\n<p>其实渐进增强和优雅降级并非什么新概念，只是旧的概念换了一个新的说法。在传统软件开发中，经常会提到向上兼容和向下兼容的概念。渐进增强相当于向上兼容，而优雅降级相当于向下兼容。向下兼容指的是高版本支持低版本的或者说后期开发的版本支持和兼容早期开发的版本，向上兼容的很少。大多数软件都是向下兼容的，比如说Office2010能打开Office2007，Office2006，Office2005，Office2003等建的word文件，但是用Office2003就不能打开用Office2007，Office2010等建的word文件！</p>\n<h5 id=\"二者的区别\"><a href=\"#二者的区别\" class=\"headerlink\" title=\"二者的区别\"></a>二者的区别</h5><p>优雅降级和渐进增强只是看待同种事物的两种观点。优雅降级和渐进增强都关注于同一网站在不同设备里不同浏览器下的表现程度。关键的区别则在于它们各自关注于何处，以及这种关注如何影响工作的流程。</p>\n<p>优雅降级观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。你可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。</p>\n<p>渐进增强观点则认为应关注于内容本身。请注意其中的差别：我甚至连“浏览器”三个字都没提。内容是我们建立网站的诱因。有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得渐进增强成为一种更为合理的设计范例。这也是它立即被 Yahoo! 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在。</p>\n<h5 id=\"举个栗子\"><a href=\"#举个栗子\" class=\"headerlink\" title=\"举个栗子\"></a>举个栗子</h5><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.transition</span> &#123; <span class=\"comment\">/*优雅降级写法*/</span></span><br><span class=\"line\">  <span class=\"attribute\">-webkit-transition</span>: all .<span class=\"number\">5s</span>;</span><br><span class=\"line\">     <span class=\"attribute\">-moz-transition</span>: all .<span class=\"number\">5s</span>;</span><br><span class=\"line\">       <span class=\"attribute\">-o-transition</span>: all .<span class=\"number\">5s</span>;</span><br><span class=\"line\">          <span class=\"attribute\">transition</span>: all .<span class=\"number\">5s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.transition</span> &#123; <span class=\"comment\">/*渐进增强写法*/</span></span><br><span class=\"line\">          <span class=\"attribute\">transition</span>: all .<span class=\"number\">5s</span>;</span><br><span class=\"line\">       <span class=\"attribute\">-o-transition</span>: all .<span class=\"number\">5s</span>;</span><br><span class=\"line\">     <span class=\"attribute\">-moz-transition</span>: all .<span class=\"number\">5s</span>;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-transition</span>: all .<span class=\"number\">5s</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"渐进增强与优雅降级\"><a href=\"#渐进增强与优雅降级\" class=\"headerlink\" title=\"渐进增强与优雅降级\"></a>渐进增强与优雅降级</h3><h5 id=\"渐进增强（progressive-enhancement）\"><a href=\"#渐进增强（progressive-enhancement）\" class=\"headerlink\" title=\"渐进增强（progressive enhancement）\"></a>渐进增强（progressive enhancement）</h5><p>针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。（从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能，向页面添加无害于基础浏览器的额外样式和功能。当浏览器支持时，它们会自动地呈现出来并发挥作用。）</p>","more":"<h5 id=\"优雅降级（graceful-degradation）\"><a href=\"#优雅降级（graceful-degradation）\" class=\"headerlink\" title=\"优雅降级（graceful degradation）\"></a>优雅降级（graceful degradation）</h5><p>一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。（Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了，为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效。）</p>\n<p>其实渐进增强和优雅降级并非什么新概念，只是旧的概念换了一个新的说法。在传统软件开发中，经常会提到向上兼容和向下兼容的概念。渐进增强相当于向上兼容，而优雅降级相当于向下兼容。向下兼容指的是高版本支持低版本的或者说后期开发的版本支持和兼容早期开发的版本，向上兼容的很少。大多数软件都是向下兼容的，比如说Office2010能打开Office2007，Office2006，Office2005，Office2003等建的word文件，但是用Office2003就不能打开用Office2007，Office2010等建的word文件！</p>\n<h5 id=\"二者的区别\"><a href=\"#二者的区别\" class=\"headerlink\" title=\"二者的区别\"></a>二者的区别</h5><p>优雅降级和渐进增强只是看待同种事物的两种观点。优雅降级和渐进增强都关注于同一网站在不同设备里不同浏览器下的表现程度。关键的区别则在于它们各自关注于何处，以及这种关注如何影响工作的流程。</p>\n<p>优雅降级观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。你可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。</p>\n<p>渐进增强观点则认为应关注于内容本身。请注意其中的差别：我甚至连“浏览器”三个字都没提。内容是我们建立网站的诱因。有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得渐进增强成为一种更为合理的设计范例。这也是它立即被 Yahoo! 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在。</p>\n<h5 id=\"举个栗子\"><a href=\"#举个栗子\" class=\"headerlink\" title=\"举个栗子\"></a>举个栗子</h5><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.transition</span> &#123; <span class=\"comment\">/*优雅降级写法*/</span></span><br><span class=\"line\">  <span class=\"attribute\">-webkit-transition</span>: all .<span class=\"number\">5s</span>;</span><br><span class=\"line\">     <span class=\"attribute\">-moz-transition</span>: all .<span class=\"number\">5s</span>;</span><br><span class=\"line\">       <span class=\"attribute\">-o-transition</span>: all .<span class=\"number\">5s</span>;</span><br><span class=\"line\">          <span class=\"attribute\">transition</span>: all .<span class=\"number\">5s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.transition</span> &#123; <span class=\"comment\">/*渐进增强写法*/</span></span><br><span class=\"line\">          <span class=\"attribute\">transition</span>: all .<span class=\"number\">5s</span>;</span><br><span class=\"line\">       <span class=\"attribute\">-o-transition</span>: all .<span class=\"number\">5s</span>;</span><br><span class=\"line\">     <span class=\"attribute\">-moz-transition</span>: all .<span class=\"number\">5s</span>;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-transition</span>: all .<span class=\"number\">5s</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"变量提升和函数提升","date":"2018-05-27T12:22:15.000Z","_content":"\n### 变量提升和函数提升\n\n##### 变量提升\n\n在ES6之前，JavaScript没有块级作用域(一对花括号{}即为一个块级作用域)，只有全局作用域和函数作用域。变量提升即将变量声明提升到它所在作用域的最开始的部分。\n\n<!-- more -->\n\n```JavaScript\nconsole.log(global); // undefined\nvar global = 'global';\nconsole.log(global); // global\n \nfunction fn () {\n　　console.log(a); // undefined\n　　var a = 'aaa';\n　　console.log(a); // aaa\n}\nfn();\n\n```\n\n之所以会是以上的打印结果，是由于js的变量提升，实际上上面的代码是按照以下来执行的：\n\n```JavaScript\nvar global; // 变量提升，全局作用域范围内，此时只是声明，并没有赋值\nconsole.log(global); // undefined\nglobal = 'global'; // 此时才赋值\nconsole.log(global); // 打印出global\n \nfunction fn () {\n　　var a; // 变量提升，函数作用域范围内\n　　console.log(a);\n　　a = 'aaa';\n　　console.log(a);\n}\nfn();\n```\n\n##### 函数提升\n\njs中创建函数有两种方式：函数声明式和函数字面量式。只有函数声明才存在函数提升！如:\n\n```JavaScript\nconsole.log(f1); // function f1() {}   \nconsole.log(f2); // undefined  \nfunction f1() {}\nvar f2 = function() {}\n```\n\n只所以会有以上的打印结果，是由于js中的函数提升导致代码实际上是按照以下来执行的：\n\n```JavaScript\nfunction f1() {} // 函数提升，整个代码块提升到文件的最开始<br>　　　　　console.log(f1);   \nconsole.log(f2);   \nvar f2 = function() {}\n```\n","source":"_posts/2018-05-27-变量提升和函数提升.md","raw":"---\ntitle: 变量提升和函数提升\ndate: 2018-5-27 20:22:15\ntags: [JavaScript]\n---\n\n### 变量提升和函数提升\n\n##### 变量提升\n\n在ES6之前，JavaScript没有块级作用域(一对花括号{}即为一个块级作用域)，只有全局作用域和函数作用域。变量提升即将变量声明提升到它所在作用域的最开始的部分。\n\n<!-- more -->\n\n```JavaScript\nconsole.log(global); // undefined\nvar global = 'global';\nconsole.log(global); // global\n \nfunction fn () {\n　　console.log(a); // undefined\n　　var a = 'aaa';\n　　console.log(a); // aaa\n}\nfn();\n\n```\n\n之所以会是以上的打印结果，是由于js的变量提升，实际上上面的代码是按照以下来执行的：\n\n```JavaScript\nvar global; // 变量提升，全局作用域范围内，此时只是声明，并没有赋值\nconsole.log(global); // undefined\nglobal = 'global'; // 此时才赋值\nconsole.log(global); // 打印出global\n \nfunction fn () {\n　　var a; // 变量提升，函数作用域范围内\n　　console.log(a);\n　　a = 'aaa';\n　　console.log(a);\n}\nfn();\n```\n\n##### 函数提升\n\njs中创建函数有两种方式：函数声明式和函数字面量式。只有函数声明才存在函数提升！如:\n\n```JavaScript\nconsole.log(f1); // function f1() {}   \nconsole.log(f2); // undefined  \nfunction f1() {}\nvar f2 = function() {}\n```\n\n只所以会有以上的打印结果，是由于js中的函数提升导致代码实际上是按照以下来执行的：\n\n```JavaScript\nfunction f1() {} // 函数提升，整个代码块提升到文件的最开始<br>　　　　　console.log(f1);   \nconsole.log(f2);   \nvar f2 = function() {}\n```\n","slug":"2018-05-27-变量提升和函数提升","published":1,"updated":"2018-07-16T03:40:16.310Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjjnq1e830000ukmnmnjrld7q","content":"<h3 id=\"变量提升和函数提升\"><a href=\"#变量提升和函数提升\" class=\"headerlink\" title=\"变量提升和函数提升\"></a>变量提升和函数提升</h3><h5 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h5><p>在ES6之前，JavaScript没有块级作用域(一对花括号{}即为一个块级作用域)，只有全局作用域和函数作用域。变量提升即将变量声明提升到它所在作用域的最开始的部分。</p>\n<a id=\"more\"></a>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(global); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> global = <span class=\"string\">'global'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(global); <span class=\"comment\">// global</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">　　<span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">　　<span class=\"keyword\">var</span> a = <span class=\"string\">'aaa'</span>;</span><br><span class=\"line\">　　<span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// aaa</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn();</span><br></pre></td></tr></table></figure>\n<p>之所以会是以上的打印结果，是由于js的变量提升，实际上上面的代码是按照以下来执行的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> global; <span class=\"comment\">// 变量提升，全局作用域范围内，此时只是声明，并没有赋值</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(global); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">global = <span class=\"string\">'global'</span>; <span class=\"comment\">// 此时才赋值</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(global); <span class=\"comment\">// 打印出global</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">　　<span class=\"keyword\">var</span> a; <span class=\"comment\">// 变量提升，函数作用域范围内</span></span><br><span class=\"line\">　　<span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">　　a = <span class=\"string\">'aaa'</span>;</span><br><span class=\"line\">　　<span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn();</span><br></pre></td></tr></table></figure>\n<h5 id=\"函数提升\"><a href=\"#函数提升\" class=\"headerlink\" title=\"函数提升\"></a>函数提升</h5><p>js中创建函数有两种方式：函数声明式和函数字面量式。只有函数声明才存在函数提升！如:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(f1); <span class=\"comment\">// function f1() &#123;&#125;   </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(f2); <span class=\"comment\">// undefined  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> f2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>只所以会有以上的打印结果，是由于js中的函数提升导致代码实际上是按照以下来执行的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;&#125; <span class=\"comment\">// 函数提升，整个代码块提升到文件的最开始&lt;br&gt;　　　　　console.log(f1);   </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(f2);   </span><br><span class=\"line\"><span class=\"keyword\">var</span> f2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"变量提升和函数提升\"><a href=\"#变量提升和函数提升\" class=\"headerlink\" title=\"变量提升和函数提升\"></a>变量提升和函数提升</h3><h5 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h5><p>在ES6之前，JavaScript没有块级作用域(一对花括号{}即为一个块级作用域)，只有全局作用域和函数作用域。变量提升即将变量声明提升到它所在作用域的最开始的部分。</p>","more":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(global); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> global = <span class=\"string\">'global'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(global); <span class=\"comment\">// global</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">　　<span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">　　<span class=\"keyword\">var</span> a = <span class=\"string\">'aaa'</span>;</span><br><span class=\"line\">　　<span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// aaa</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn();</span><br></pre></td></tr></table></figure>\n<p>之所以会是以上的打印结果，是由于js的变量提升，实际上上面的代码是按照以下来执行的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> global; <span class=\"comment\">// 变量提升，全局作用域范围内，此时只是声明，并没有赋值</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(global); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">global = <span class=\"string\">'global'</span>; <span class=\"comment\">// 此时才赋值</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(global); <span class=\"comment\">// 打印出global</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">　　<span class=\"keyword\">var</span> a; <span class=\"comment\">// 变量提升，函数作用域范围内</span></span><br><span class=\"line\">　　<span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">　　a = <span class=\"string\">'aaa'</span>;</span><br><span class=\"line\">　　<span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn();</span><br></pre></td></tr></table></figure>\n<h5 id=\"函数提升\"><a href=\"#函数提升\" class=\"headerlink\" title=\"函数提升\"></a>函数提升</h5><p>js中创建函数有两种方式：函数声明式和函数字面量式。只有函数声明才存在函数提升！如:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(f1); <span class=\"comment\">// function f1() &#123;&#125;   </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(f2); <span class=\"comment\">// undefined  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> f2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>只所以会有以上的打印结果，是由于js中的函数提升导致代码实际上是按照以下来执行的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;&#125; <span class=\"comment\">// 函数提升，整个代码块提升到文件的最开始&lt;br&gt;　　　　　console.log(f1);   </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(f2);   </span><br><span class=\"line\"><span class=\"keyword\">var</span> f2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjjnpdxp40000sdmn6l5pvzqx","tag_id":"cjjnpdxpe0002sdmnt5usm88y","_id":"cjjnpdxpn000bsdmn0ovko526"},{"post_id":"cjjnpdxp40000sdmn6l5pvzqx","tag_id":"cjjnpdxpj0006sdmnrzfvmbsn","_id":"cjjnpdxpq000dsdmnr10g70yd"},{"post_id":"cjjnpdxpb0001sdmnxe1g4bo6","tag_id":"cjjnpdxpl0009sdmnqaig6dql","_id":"cjjnpdxpr000fsdmntvi54g30"},{"post_id":"cjjnpdxpf0003sdmn2c9p2p2i","tag_id":"cjjnpdxpq000esdmnrj0yj8w2","_id":"cjjnpdxps000hsdmn7o540lss"},{"post_id":"cjjnpdxph0004sdmnlrsqy3vn","tag_id":"cjjnpdxpr000gsdmn5cmjl799","_id":"cjjnpdxpv000ksdmnewy602q4"},{"post_id":"cjjnpdxph0004sdmnlrsqy3vn","tag_id":"cjjnpdxpt000isdmnbxbuzb2w","_id":"cjjnpdxpw000lsdmnv8gink2o"},{"post_id":"cjjnpdxpi0005sdmngtq1h5mc","tag_id":"cjjnpdxpt000jsdmnepk8sm16","_id":"cjjnpdxpw000nsdmnezfcpg1b"},{"post_id":"cjjnpdxpj0007sdmnxd7tg876","tag_id":"cjjnpdxpw000msdmnxsmci0yn","_id":"cjjnpdxq2000rsdmnd8xel6iy"},{"post_id":"cjjnpdxpj0007sdmnxd7tg876","tag_id":"cjjnpdxpx000osdmnx4i8idh7","_id":"cjjnpdxq3000ssdmnrr1wanvr"},{"post_id":"cjjnpdxpj0007sdmnxd7tg876","tag_id":"cjjnpdxpz000psdmn2tic8fni","_id":"cjjnpdxq5000usdmnro4wnex5"},{"post_id":"cjjnpdxpk0008sdmn8ywwmc3s","tag_id":"cjjnpdxq1000qsdmn8ca2gq17","_id":"cjjnpdxq6000vsdmnpdm6r3ca"},{"post_id":"cjjnpdxpm000asdmno1nilplm","tag_id":"cjjnpdxq1000qsdmn8ca2gq17","_id":"cjjnpdxq8000xsdmnd9dv8rqy"},{"post_id":"cjjnpdxpm000asdmno1nilplm","tag_id":"cjjnpdxq6000wsdmni7l4w9vy","_id":"cjjnpdxq8000ysdmnsaximp3w"},{"post_id":"cjjnphwrd0000szmnw9kbqz67","tag_id":"cjjnphwrj0001szmn4yq42mhm","_id":"cjjnphwrq0002szmnkbn8flr9"},{"post_id":"cjjnq1e830000ukmnmnjrld7q","tag_id":"cjjnpdxpx000osdmnx4i8idh7","_id":"cjjnq1e880001ukmnxtz2m8b9"}],"Tag":[{"name":"前端工程化","_id":"cjjnpdxpe0002sdmnt5usm88y"},{"name":"前后端分离","_id":"cjjnpdxpj0006sdmnrzfvmbsn"},{"name":"Git","_id":"cjjnpdxpl0009sdmnqaig6dql"},{"name":"前端架构","_id":"cjjnpdxpq000esdmnrj0yj8w2"},{"name":"API","_id":"cjjnpdxpr000gsdmn5cmjl799"},{"name":"工具","_id":"cjjnpdxpt000isdmnbxbuzb2w"},{"name":"HTTP","_id":"cjjnpdxpt000jsdmnepk8sm16"},{"name":"CSS","_id":"cjjnpdxpw000msdmnxsmci0yn"},{"name":"JavaScript","_id":"cjjnpdxpx000osdmnx4i8idh7"},{"name":"前端动画","_id":"cjjnpdxpz000psdmn2tic8fni"},{"name":"React","_id":"cjjnpdxq1000qsdmn8ca2gq17"},{"name":"ref","_id":"cjjnpdxq6000wsdmni7l4w9vy"},{"name":"Css","_id":"cjjnphwrj0001szmn4yq42mhm"}]}}